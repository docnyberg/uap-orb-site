<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>UAP / Orb Atlas Viewer</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="dark light">
    <style>
        :root {
            --bg: #0b1220;
            --fg: #c9d3e5;
            --muted: #94a3b8;
            --card: #0f172a;
            --border: #1e293b;
            --accent: #58a6ff;
            --thumb: 240px;
            --gap: 10px;
            --radius: 10px;
        }

        * {
            box-sizing: border-box
        }

        html, body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial
        }

        a {
            color: var(--accent);
            text-decoration: none
        }

            a:hover {
                opacity: .9
            }

        button {
            cursor: pointer
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 14px
        }

        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center
        }

        h1 {
            font-size: 18px;
            margin: 0 0 8px 0
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: var(--card);
            color: var(--fg);
            font-size: 12px
        }

        .small {
            font-size: 12px;
            color: var(--muted)
        }

        .mono {
            font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace
        }

        .hr {
            height: 1px;
            background: var(--border);
            margin: 10px 0
        }

        /* Controls */
        .controls {
            display: grid;
            grid-template-columns: repeat(12,1fr);
            gap: 10px;
            margin: 8px 0 12px
        }

            .controls .group {
                grid-column: span 12;
                display: flex;
                flex-wrap: wrap;
                gap: 8px;
                align-items: center
            }

        @media(min-width:900px) {
            .controls .g-left {
                grid-column: span 8
            }

            .controls .g-right {
                grid-column: span 4;
                justify-content: flex-end
            }
        }

        select, input[type="range"], input[type="text"] {
            background: var(--card);
            border: 1px solid var(--border);
            color: var(--fg);
            border-radius: 8px;
            padding: 6px 8px;
            outline: none
        }

        label {
            user-select: none
        }

        .btn {
            padding: 6px 10px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--card);
            color: var(--fg)
        }

            .btn.primary {
                border-color: #6fb5ff
            }

            .btn[disabled] {
                opacity: .6;
                cursor: not-allowed
            }

        /* Grid */
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill,minmax(var(--thumb),1fr));
            gap: var(--gap)
        }

        .card {
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--card);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative
        }

            .card .imgwrap {
                width: 100%;
                aspect-ratio: 1/1;
                background: #000;
                display: flex;
                align-items: center;
                justify-content: center;
                overflow: hidden
            }

            .card img {
                width: 100%;
                height: 100%;
                object-fit: cover
            }

            .card .meta {
                padding: 8px;
                border-top: 1px solid var(--border)
            }

                .card .meta .row {
                    gap: 6px
                }

        .pill {
            padding: 4px 8px;
            border: 1px solid var(--border);
            border-radius: 999px;
            background: transparent;
            color: var(--fg);
            font-size: 12px
        }

        .actions {
            position: absolute;
            top: 6px;
            right: 6px;
            display: flex;
            gap: 6px
        }

        .btn-mini {
            background: #0008;
            border: 1px solid #7688a3;
            color: #fff;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 6px
        }

        /* Modal */
        .overlay {
            position: fixed;
            inset: 0;
            background: #000a;
            display: none;
            z-index: 100
        }

        .modal {
            max-width: 1000px;
            margin: 6vh auto;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            color: var(--fg)
        }

        .modal-head {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .modal-body {
            display: grid;
            grid-template-columns: 1fr 240px;
            gap: 10px;
            margin-top: 10px
        }

        .viewer {
            width: 100%;
            aspect-ratio: 1/1;
            background: #000;
            border: 1px solid var(--border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden
        }

            .viewer img, .viewer canvas {
                max-width: 100%;
                max-height: 100%
            }

        .modal-meta {
            font-size: 13px;
            color: var(--muted)
        }

        .modal-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px
        }

            .modal-controls .nav {
                margin-left: auto;
                display: flex;
                gap: 6px
            }

        /* Carousel strip */
        .modal-carousel {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-height: 540px;
            overflow: auto
        }

            .modal-carousel img.carousel-thumb {
                height: 84px;
                border: 2px solid transparent;
                border-radius: 6px;
                cursor: pointer;
                object-fit: cover;
                background: #000
            }

                .modal-carousel img.carousel-thumb.selected {
                    border-color: var(--accent);
                    box-shadow: 0 0 0 2px rgba(88,166,255,.25)
                }

                .modal-carousel img.carousel-thumb.wm {
                    opacity: .55;
                    filter: grayscale(.2)
                }

        @media (max-width:700px) {
            .modal-body {
                grid-template-columns: 1fr
            }

            .modal-carousel img.carousel-thumb {
                height: 64px
            }
        }

        /* Pro modal */
        .overlay-lite {
            position: fixed;
            inset: 0;
            background: #000a;
            display: none;
            z-index: 110
        }

        .modal-lite {
            max-width: 560px;
            margin: 8vh auto;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            color: var(--fg)
        }

            .modal-lite h3 {
                margin: 0 0 8px 0
            }

            .modal-lite .row {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                margin-top: 12px
            }

        /* Color chips */
        .chips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap
        }

        .chip {
            width: 22px;
            height: 16px;
            border-radius: 5px;
            border: 1px solid var(--border);
            cursor: pointer
        }

            .chip.sel {
                outline: 2px solid #fff5
            }

        /* Utility */
        .hide {
            display: none !important
        }

        .muted {
            color: var(--muted)
        }

        .note {
            margin: 6px 0 0 0;
            color: var(--muted)
        }

        .status {
            min-height: 18px;
            color: var(--muted)
        }
    </style>

    <!-- PayPal JS SDK -->
    <script src="https://www.paypal.com/sdk/js?client-id=AWKc_8sVqOfeg9nU-wxnu25qmouXvoL63V2YlA96prh_stIc0erylu526vatGSmxsqNu-L_IaimV1yA3&currency=USD"></script>
    <!-- PapaParse -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>UAP / Orb Atlas Viewer</h1>

        <!-- Top badges -->
        <div class="row">
            <div class="badge">View: <span id="viewBadge">All</span></div>
            <div class="badge">Items: <span id="countBadge">0</span></div>
            <div class="badge">Downloads: <span id="dlBadge" class="mono">img 0 / svg 0</span></div>
            <div class="badge"><span id="proBadge" class="mono">Free</span></div>
            <div class="badge" id="visitorsBadge">— visitors</div>
            <div class="status mono" id="status"></div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="group g-left">
                <label>
                    Group by
                    <select id="groupSelect">
                        <option value="video" selected>Source video</option>
                        <option value="none">None</option>
                        <option value="hue">Hue</option>
                        <option value="brightness">Brightness</option>
                        <option value="saturation">Saturation</option>
                        <option value="time">Time</option>
                    </select>
                </label>

                <label>
                    Sort by
                    <select id="sortSelect">
                        <option value="start_ts" selected>Start time</option>
                        <option value="hue">Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="brightness">Brightness</option>
                        <option value="sharpness">Sharpness</option>
                        <option value="area">Area</option>
                        <option value="hueRange">ΔHue</option>
                        <option value="hueRange_pro">ΔHue (Pro)</option>
                        <option value="sharpArea_pro">Sharpness × Area (Pro)</option>
                    </select>
                    <button id="sortDirBtn" class="btn" title="Toggle ascending/descending">↓</button>
                </label>

                <label>
                    Tile size
                    <input id="sizeRange" type="range" min="120" max="420" step="10" value="240">
                </label>

                <label>
                    Thumbs
                    <select id="thumbMode">
                        <option value="object" selected>Object</option>
                        <option value="scene">Scene</option>
                    </select>
                </label>

                <label>
                    SVG style
                    <select id="svgStyle">
                        <option value="default" selected>Default</option>
                        <option value="outline">Outline</option>
                        <option value="smooth">Smooth</option>
                        <option value="bezier">Bézier</option>
                        <option value="skeleton">Skeleton</option>
                        <option value="rings">Rings</option>
                        <option value="hull">Hull</option>
                        <option value="edges">Edges</option>
                        <option value="ellipse">Ellipse</option>
                    </select>
                </label>

                <label class="pill"><input type="checkbox" id="imgOnly" checked> Images only</label>
                <label class="pill"><input type="checkbox" id="hideDup"> Hide duplicates</label>
                <label class="pill"><input type="checkbox" id="collapseDS"> Collapse dead space</label>
            </div>

            <div class="group g-right">
                <input id="search" type="text" placeholder="Search (filename or hex) …" style="min-width:240px">
                <button id="resetBtn" class="btn">Reset</button>
                <button id="upgradeBtn" class="btn primary">Upgrade</button>
                <a id="donateBtn" class="btn" target="_blank" rel="noopener">Donate</a>
            </div>

            <!-- Advanced filters drawer -->
            <div class="group" style="grid-column:span 12">
                <details id="advanced" style="border:1px solid var(--border);border-radius:10px;background:var(--card);width:100%">
                    <summary style="cursor:pointer;padding:8px 12px;color:#c9d3e5">Advanced filters (hue, motion tier, shapes, color groups)</summary>
                    <div class="row" style="padding:8px 12px">
                        <div style="display:flex;align-items:center;gap:8px">
                            <strong>Hue</strong>
                            <input type="range" id="hmin" min="0" max="360" value="3">
                            <input type="range" id="hmax" min="0" max="360" value="360">
                            <span id="hbadge" class="badge">3°–360°</span>
                        </div>
                        <div>
                            <label>
                                <strong title="Relative motion of object">Motion tier:</strong>
                                <select id="motionTier">
                                    <option value="any" selected>Any</option>
                                    <option value="low">Low</option>
                                    <option value="med">Medium</option>
                                    <option value="high">High</option>
                                </select>
                            </label>
                        </div>
                        <div id="shapeBox" style="display:flex;gap:12px;flex-wrap:wrap"></div>
                        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                            <strong>Color:</strong>
                            <div id="colorChips" class="chips"></div>
                        </div>
                    </div>
                </details>
            </div>
        </div>

        <div class="note" id="note">Loading…</div>
        <div class="hr"></div>

        <!-- Grid -->
        <div id="grid" class="grid"></div>
        <div id="sentinel" style="height:1px"></div>
    </div>

    <!-- Modal viewer -->
    <div id="modal" class="overlay" role="dialog" aria-modal="true">
        <div class="modal">
            <div class="modal-head">
                <div class="badge">Series: <span id="modalSeries" class="mono">–</span></div>
                <div class="badge">Frame <span id="modalPos" class="mono">0</span>/<span id="modalLen" class="mono">0</span></div>
                <div class="badge">Time <span id="modalTime" class="mono">–</span></div>
                <button id="modalClose" class="btn" style="margin-left:auto">Close</button>
            </div>

            <div class="modal-body">
                <div>
                    <div class="viewer" id="viewer"><!-- image/canvas injected --></div>
                    <div class="modal-meta" id="modalMeta"></div>

                    <div class="modal-controls">
                        <div class="toggle"><label><input type="checkbox" id="modalSvgToggle"> SVG view</label></div>
                        <div class="spacer"></div>
                        <a id="dlImg" class="btn" download>Download image</a>
                        <button id="dlVideo" class="btn" title="Download current carousel as MP4">Download MP4</button>
                        <div class="nav">
                            <button id="modalPrev" title="Previous in sequence">← Prev</button>
                            <button id="modalNext" title="Next in sequence">Next →</button>
                        </div>
                    </div>
                </div>

                <div class="modal-carousel" id="carousel"></div>
            </div>
        </div>
    </div>

    <!-- Pro / Upgrade modal -->
    <div id="proModal" class="overlay-lite">
        <div class="modal-lite">
            <h3>Upgrade to Orb Atlas Pro</h3>
            <div>Unlock advanced sorts, more downloads, and extended datasets.</div>
            <div id="paypal-upgrade" style="margin:10px 0;"></div>
            <div class="row">
                <a id="goDonate" class="btn" target="_blank" rel="noopener">Donate (Venmo)</a>
                <button id="iPaid" class="btn">I already upgraded</button>
                <button id="closePro" class="btn">Later</button>
            </div>
        </div>
    </div>


    <script>
        /* =========================
           Tiny DOM helpers & state
           ========================= */
        const $ = sel => document.querySelector(sel);
        const $$ = sel => Array.from(document.querySelectorAll(sel));
        const num = (x, d = 0) => { const v = +x; return Number.isFinite(v) ? v : d };

        let DATA = [];           // full dataset
        let CURRENT = [];        // filtered/sorted items (objects)
        let CURRENT_IDX = [];    // indices back into DATA
        let groupMode = "video"; // default
        let sortMode = "start_ts";
        let sortAsc = false;     // newest first when sorting by time
        let thumbMode = "object";
        let svgStyle = "default";
        let currentView = "all";
        let MODAL = null;

        // Video file mapping
        const VIDEO_FILES = {
            'aguadilla_plaza': 'vids/aguadilla_plaza.mp4',
            'columbus_oh': 'vids/columbus_oh.mp4',
            // ... etc
        };

        // Helper to get video key from filename
        function getVideoKey(videoFile) {
            if (!videoFile) return null;
            return videoFile.replace(/\.[^.]+$/, '').replace(/_\d+$/, '');
        }

        function getCurrentObjectIdFromModal() {
            const gi = MODAL?.seq?.[MODAL?.pos];
            return Number.isInteger(gi) ? DATA[gi]?.id : null;
        }

        function normalizeVideoFileName(name) {
            if (!name) return null;
            let v = String(name).trim();
            // keep only the base filename (no folders)
            v = v.split(/[\\/]/).pop();
            // ensure exactly one .mp4 (fixes cases like .mp4.mp4)
            v = v.replace(/(\.mp4)+$/i, '');
            return v + '.mp4';
        }


        /* =========================
   Pro gating & counters with tamper resistance
   ========================= */
        function isPro() { return localStorage.getItem('atlas_pro') === '1' || !!localStorage.getItem('atlas_pro_token'); }
        function setPro() { localStorage.setItem('atlas_pro', '1'); updateBadges(); }

        // We'll use multiple storage mechanisms and a hash
        function getDownloadSignature() {
            const now = Math.floor(Date.now() / (1000 * 60 * 60 * 24)); // Current day
            return btoa(`${navigator.userAgent.slice(0, 20)}:${now}`); // Simple signature
        }

        function getDL(kind) {
            // Check multiple storage locations
            const lsCount = +(localStorage.getItem('dl_' + kind) || 0);
            const ssCount = +(sessionStorage.getItem('dl_' + kind) || 0);
            const dlSig = localStorage.getItem('dl_sig');

            // If we have a download signature but counts are 0, likely tampered
            if (dlSig && lsCount === 0 && ssCount === 0) {
                // Restore to a high value to discourage tampering
                setDL(kind, FREE_LIMIT - 1);
                return FREE_LIMIT - 1;
            }

            // Use the highest count we find
            return Math.max(lsCount, ssCount);
        }

        function setDL(kind, val) {
            const count = Math.max(0, val | 0);
            localStorage.setItem('dl_' + kind, String(count));
            sessionStorage.setItem('dl_' + kind, String(count));

            // Store a signature of download activity
            if (count > 0) {
                localStorage.setItem('dl_sig', getDownloadSignature());
                document.cookie = `dl_act=1; path=/; max-age=${60 * 60 * 24 * 30}`;
            }

            updateBadges();
        }

        // Allow 3 free image and 3 free svg downloads by default
        const FREE_LIMIT = 3;

        function allowDownload(kind) {
            if (isPro()) return true;
            const used = getDL(kind);
            if (used >= FREE_LIMIT) {
                showProModal();
                alert(`Free ${kind.toUpperCase()} downloads exhausted. Please upgrade to Pro.`);
                return false;
            }
            return true;
        }

        function recordDownload(kind) {
            if (!isPro()) setDL(kind, getDL(kind) + 1);
        }

        function recordVideoDownload(kind) {
            if (!isPro()) setDL(kind, getDL(kind) + 2);
        }

        function updateBadges() {
            $('#dlBadge').textContent = `img ${getDL('image')} / svg ${getDL('svg')}`;
            $('#proBadge').textContent = isPro() ? 'Pro' : 'Free';
        }

        /* =========================
           Monetization wiring
           ========================= */
        function showProModal() { $('#proModal').style.display = 'block'; renderPayPalUpgradeButton(); }
        function hideProModal() { $('#proModal').style.display = 'none'; }

        (function initDonationLinks() {
            const venmo = "https://venmo.com/code?user_id=3930194146494448567&created=1756688818.684348&printed=1";
            $('#donateBtn').href = venmo;
            const goD = $('#goDonate'); if (goD) goD.href = venmo;
        })();

        function renderPayPalUpgradeButton() {
            if (!window.paypal || !document.getElementById('paypal-upgrade')) return;
            if (document.getElementById('paypal-upgrade').dataset.rendered === '1') return;
            const PRICE = 1.99;
            paypal.Buttons({
                style: { layout: 'horizontal', color: 'gold', shape: 'pill', label: 'pay' },
                createOrder: (data, actions) => actions.order.create({
                    purchase_units: [{ amount: { value: PRICE.toFixed(2), currency_code: 'USD' } }]
                }),
                onApprove: async (data, actions) => {
                    try {
                        const orderID = data.orderID;
                        const res = await fetch('/.netlify/functions/verify-paypal', {
                            method: 'POST', headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ orderID })
                        });
                        if (!res.ok) { const t = await res.text().catch(() => ''); alert('Payment verification failed.\\n' + t); return; }
                        const json = await res.json();
                        if (!json || !json.token) { alert('No token returned from server.'); return; }
                        localStorage.setItem('atlas_pro_token', json.token);
                        localStorage.setItem('atlas_pro', '1');
                        alert('Thanks! Pro is now unlocked on this browser.');
                        hideProModal(); updateBadges();
                    } catch (e) { console.error(e); alert('Unexpected error verifying payment.'); }
                },
                onError: (err) => { console.error('PayPal error:', err); alert('PayPal error. Please try again.'); }
            }).render('#paypal-upgrade');
            document.getElementById('paypal-upgrade').dataset.rendered = '1';
        }

        /* =========================
           CSV loading & normalize
           ========================= */
        function loadCSV() {
            return new Promise((resolve, reject) => {
                Papa.parse('atlas.csv', {
                    download: true, header: true, dynamicTyping: false, skipEmptyLines: true,
                    complete: (res) => {
                        try {
                            const rows = res.data || [];
                            DATA = rows.map((r, i) => normalizeRow(r, i));
                            resolve(DATA);
                        } catch (e) { reject(e); }
                    },
                    error: reject
                });
            });
        }

        function normalizeRow(r, i) {
            // Expected fields (best-effort; tolerate missing)
            const thumb = (r.thumb || '').trim();
            const thumbObj = (r.thumb_obj || r.thumb_obj_file || '').trim();
            const svg = (r.svg || r.svg_file || '').trim();
            const vf = (r.video_file || r.source || r.video || '').trim();

            const start = num(r.start_ts, num(r.ts_start, NaN));
            const end = num(r.end_ts, num(r.ts_end, NaN));

            const h = num(r.h_norm, num(r.h, NaN));
            const s = num(r.s_norm, num(r.s, NaN));
            const v = num(r.v_norm, num(r.v, NaN));
            const hex = (r.hex || r.color || '').replace('#', '').toLowerCase();

            const sharp = num(r.sharpness, NaN);
            const area = num(r.area_norm, NaN);
            const circ = num(r.circ, NaN);
            const hRange = num(r.h_range_deg, NaN);
            const shape = (r.shape || r.shape_class || 'other') || 'other';
            const motion = (r.motion || r.motion_class || 'unknown') || 'unknown';

            const id = (r.id || `${i}`).toString();

            return {
                _i: i, id, video_file: vf,
                thumb: thumb, thumb_obj: thumbObj, svg: svg,
                start_ts: start, end_ts: end,
                h_norm: h, s_norm: s, v_norm: v,
                hex,
                sharpness: sharp, area_norm: area, circ, h_range_deg: hRange,
                shape, motion,
                isDuplicate: false,
                hasWatermark: vf && vf.toLowerCase().includes('tiktok')
            };
        }

        /* =========================
           Hue & color helpers
           ========================= */
        function hueOf(row) {
            const h = num(row.h_norm, NaN);
            if (Number.isFinite(h)) return ((h % 360) + 360) % 360;
            // Try hex fallback
            let hex = row.hex;
            if (!hex) return NaN;
            hex = String(hex).trim();
            if (hex[0] === '#') hex = hex.slice(1);
            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
            if (!/^[0-9a-fA-F]{6}$/.test(hex)) return NaN;
            const n = parseInt(hex, 16);
            const r = (n >> 16 & 255) / 255, g = (n >> 8 & 255) / 255, b = (n & 255) / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b), d = max - min;
            if (d === 0) return NaN;
            let hdeg;
            if (max === r) hdeg = ((g - b) / d) * 60;
            else if (max === g) hdeg = (2 + (b - r) / d) * 60;
            else hdeg = (4 + (r - g) / d) * 60;
            if (hdeg < 0) hdeg += 360;
            return hdeg;
        }

        function colorGroup(it) {
            const h = hueOf(it), s = num(it.s_norm, 0), v = num(it.v_norm, 0);
            if (!Number.isFinite(h) || s < 0.1) return v > 0.8 ? "White" : (v < 0.2 ? "Black" : "Gray");
            if (h < 15 || h >= 345) return "Red"; if (h < 45) return "Orange"; if (h < 75) return "Yellow";
            if (h < 150) return "Green"; if (h < 210) return "Cyan"; if (h < 270) return "Blue";
            if (h < 300) return "Purple"; if (h < 345) return "Magenta"; return "Other";
        }

        /* =========================
           Dead space (black) detect
           ========================= */
        function isBlackTile(it) {
            const s = num(it.s_norm, 0);
            const v = num(it.v_norm, 0);
            const h = it.h_norm;
            if ((!Number.isFinite(h) || s < 0.10) && v < 0.20) return true;
            if (it.hex === '000000') return true;
            return false;
        }

        /* =========================
           Dedupe by video clusters
           ========================= */
        function dedupeByVideoClusters() {
            const byVid = {}; DATA.forEach((it, i) => { const v = it.video_file || "_"; (byVid[v] || (byVid[v] = [])).push(i); });
            for (const vid in byVid) {
                const idxs = byVid[vid].sort((a, b) => num(DATA[a].start_ts, 0) - num(DATA[b].start_ts, 0));
                let i = 0;
                while (i < idxs.length) {
                    let rep = idxs[i], repSharp = num(DATA[rep].sharpness, 0), j = i + 1;
                    while (j < idxs.length) {
                        const A = idxs[i], B = idxs[j];
                        if (Math.abs(num(DATA[B].start_ts, 0) - num(DATA[A].start_ts, 0)) <= 1.0) {
                            let dh = Math.abs(hueOf(DATA[B]) - hueOf(DATA[A])); dh = Math.min(dh, 360 - dh);
                            const same = (DATA[B].shape === DATA[A].shape);
                            if (dh < 15 && same) { const sB = num(DATA[B].sharpness, 0); if (sB > repSharp) { rep = idxs[j]; repSharp = sB; } j++; continue; }
                        }
                        break;
                    }
                    for (let k = i; k < j; k++) { const x = idxs[k]; DATA[x].isDuplicate = (x !== rep); }
                    i = j;
                }
            }
        }

        /* =========================
           Filtering & sorting
           ========================= */
        function applyFilters() {
            let list = DATA.map((it, gi) => ({ it, gi }));

            const imagesOnly = $('#imgOnly').checked;
            if (imagesOnly) {
                list = list.filter(x => (x.it.thumb_obj && String(x.it.thumb_obj).trim() !== "") || (x.it.thumb && String(x.it.thumb).trim() !== ""));
            }

            const q = $('#search').value.trim().toLowerCase();
            if (q) {
                list = list.filter(({ it }) => {
                    return (it.video_file || '').toLowerCase().includes(q) ||
                        (it.thumb || '').toLowerCase().includes(q) ||
                        (it.thumb_obj || '').toLowerCase().includes(q) ||
                        (it.svg || '').toLowerCase().includes(q) ||
                        (it.hex || '').toLowerCase().includes(q);
                });
            }

            if ($('#hideDup').checked) {
                list = list.filter(({ it }) => !it.isDuplicate);
            }

            // Advanced: hue range
            const hmin = parseInt($("#hmin").value || "0", 10);
            const hmax = parseInt($("#hmax").value || "360", 10);
            $('#hbadge').textContent = `${hmin}°–${hmax}°`;
            list = list.filter(({ it }) => {
                const h = hueOf(it);
                if (!Number.isFinite(h)) return true; // keep gray/black
                return (hmin <= hmax) ? (h >= hmin && h <= hmax) : (h >= hmin || h <= hmax);
            });

            // Advanced: motion tier
            const tier = $("#motionTier").value;
            if (tier !== "any") {
                list = list.filter(({ it }) => (it.motionTier || 'low') === tier);
            }

            // Advanced: shapes
            const scb = [...document.querySelectorAll('#shapeBox input[type=checkbox]')];
            const enabledShapes = new Set(scb.filter(cb => cb.checked).map(cb => cb.dataset.shape));
            if (enabledShapes.size) {
                list = list.filter(({ it }) => enabledShapes.has(it.shape || 'other'));
            }

            // Advanced: color chips (optional)
            const chips = [...document.querySelectorAll('#colorChips .chip.sel')];
            const colorSel = new Set(chips.map(c => c.dataset.color));
            if (colorSel.size) {
                list = list.filter(({ it }) => colorSel.has(colorGroup(it)));
            }

            // Sort
            const mode = sortMode;
            const asc = sortAsc ? 1 : -1;
            function orderKeyFor(it) {
                switch (mode) {
                    case 'start_ts': return num(it.start_ts, -999);
                    case 'hue': return hueOf(it);
                    case 'saturation': return num(it.s_norm, -999);
                    case 'brightness': return num(it.v_norm, -999);
                    case 'sharpness': return num(it.sharpness, -999);
                    case 'area': return num(it.area_norm, -999);
                    case 'hueRange': return num(it.h_range_deg, -999);
                    case 'hueRange_pro': return isPro() ? num(it.h_range_deg, -999) : -999;
                    case 'sharpArea_pro': return isPro() ? (num(it.sharpness, 0) * num(it.area_norm, 0)) : -999;
                    default: return it._i;
                }
            }

            if (groupMode === 'video') {
                list.sort((a, b) => {
                    if (a.it.video_file < b.it.video_file) return -1;
                    if (a.it.video_file > b.it.video_file) return 1;
                    const A = orderKeyFor(a.it), B = orderKeyFor(b.it);
                    return ((Number.isFinite(A) ? A : -999) - (Number.isFinite(B) ? B : -999)) * asc;
                });
            } else {
                list.sort((a, b) => {
                    const A = orderKeyFor(a.it), B = orderKeyFor(b.it);
                    return ((Number.isFinite(A) ? A : -999) - (Number.isFinite(B) ? B : -999)) * asc;
                });
            }

            CURRENT = list.map(x => x.it);
            CURRENT_IDX = list.map(x => x.gi);

            if ($('#collapseDS').checked) {
                const outIt = [], outGi = [];
                for (let i = 0; i < CURRENT.length; i++) {
                    const it = CURRENT[i];
                    const gi = CURRENT_IDX[i];
                    if (!isBlackTile(it)) { outIt.push(it); outGi.push(gi); continue; }
                    let j = i;
                    let last = it;
                    while (j + 1 < CURRENT.length) {
                        const nextIt = CURRENT[j + 1];
                        if (!isBlackTile(nextIt)) break;
                        if (nextIt.video_file !== it.video_file) break;
                        j++;
                        last = nextIt;
                    }
                    if (j > i) {
                        const origEnd = it._orig_end_ts ?? it.end_ts;
                        const lastEnd = last.end_ts;
                        if (it._orig_end_ts === undefined) it._orig_end_ts = origEnd;
                        it.end_ts = lastEnd;
                    }
                    outIt.push(it); outGi.push(gi);
                    i = j;
                }
                CURRENT = outIt; CURRENT_IDX = outGi;
            }
        }

        function updateNote() {
            const view = (groupMode === 'video') ? 'Grouped by Source video' : (groupMode === 'none' ? 'All' : `Grouped by ${$('#groupSelect').selectedOptions[0].text}`);
            $('#viewBadge').textContent = view;
            $('#countBadge').textContent = String(CURRENT.length);
        }

        /* =========================
           Streaming grid (infinite)
           ========================= */
        let STREAM = { i: 0, FIRST: 400, STEP: 600, observer: null };

        function thumbUrlFor(it) {
            if (thumbMode === 'object' && it.thumb_obj) return `thumbs_obj/${it.thumb_obj}`;
            if (thumbMode === 'scene' && it.thumb) return `thumbs/${it.thumb}`;
            return it.thumb_obj ? `thumbs_obj/${it.thumb_obj}` : `thumbs/${it.thumb}`;
        }

        function cardHTML(it, gi) {
            const src = thumbUrlFor(it);
            const st = num(it.start_ts, 0).toFixed(2), en = num(it.end_ts, st + 1 / 30).toFixed(2);
            const hueLbl = Number.isFinite(hueOf(it)) ? `${hueOf(it).toFixed(1)}°` : '–';
            const vf = it.video_file || '–';
            return `
              <div class="card" data-idx="${gi}">
                <div class="imgwrap"><img loading="lazy" decoding="async" class="thumb" src="${src}" alt=""></div>
                <div class="actions">
                  <button class="btn-mini" data-action="open" title="Open">Open</button>
                  <button class="btn-mini" data-action="sim" title="Find similar">Similar</button>
                  ${thumbMode === 'object'
                    ? `<button class="btn-mini" data-action="svg" title="View SVG">SVG</button>`
                    : ``}
                </div>
                <div class="meta">
                  <div class="row">
                    <span class="pill mono">${vf}</span>
                    <span class="pill mono">${st}–${en}s</span>
                    <span class="pill mono">h=${hueLbl}</span>
                  </div>
                </div>
              </div>`;
        }

        function wireTileClicks(start, end) {
            const cards = $('#grid').querySelectorAll('.card');
            const slice = [...cards].slice(start, end);
            slice.forEach(card => {
                const idx = +card.dataset.idx;
                card.addEventListener('click', e => {
                    const a = e.target && e.target.dataset && e.target.dataset.action;
                    if (a === 'sim' || a === 'svg' || a === 'open') return; // use buttons
                    openModalAtGlobalIndex(idx, false);
                });
                const btnOpen = card.querySelector('[data-action="open"]');
                const btnSim = card.querySelector('[data-action="sim"]');
                const btnSvg = card.querySelector('[data-action="svg"]');
                if (btnOpen) btnOpen.addEventListener('click', (e) => { e.stopPropagation(); openModalAtGlobalIndex(idx, false); });
                if (btnSim) btnSim.addEventListener('click', (e) => { e.stopPropagation(); findSimilarByGlobalIndex(idx); });
                if (btnSvg) btnSvg.addEventListener('click', (e) => { e.stopPropagation(); openModalAtGlobalIndex(idx, true); });
            });
        }

        function appendChunk(n) {
            const start = STREAM.i, end = Math.min(STREAM.i + n, CURRENT.length);
            if (start >= end) return;

            const frag = CURRENT.slice(start, end).map((it, localIdx) => {
                const gi = CURRENT_IDX[start + localIdx];
                return cardHTML(it, gi);
            }).join('');

            $('#grid').insertAdjacentHTML('beforeend', frag);
            wireTileClicks(start, end);
            STREAM.i = end;

            $('#countBadge').textContent = String(CURRENT.length);
            if (STREAM.i >= CURRENT.length && STREAM.observer) {
                STREAM.observer.disconnect(); STREAM.observer = null;
            }
        }

        function startStreaming() {
            const g = $('#grid'); g.innerHTML = '';
            STREAM.i = 0;
            appendChunk(STREAM.FIRST);
            if (STREAM.observer) STREAM.observer.disconnect();
            STREAM.observer = new IntersectionObserver((entries) => {
                entries.forEach(e => { if (e.isIntersecting) appendChunk(STREAM.STEP); });
            }, { root: null, rootMargin: '800px 0px 800px 0px', threshold: 0 });
            STREAM.observer.observe($('#sentinel'));
            updateNote();
            const sEl = $('#status'); if (sEl) sEl.textContent = '';
        }

        /* =========================
           Grouped render
           ========================= */
        function groupAndRender(items) {
            const keys = {}, order = [];
            function add(key, item) { if (!keys[key]) { keys[key] = []; order.push(key); } keys[key].push(item); }

            if (groupMode === "hue") {
                items.forEach(it => { const h = hueOf(it); const bin = Number.isFinite(h) ? Math.floor(h / 15) : 24; add(`Hue ${bin * 15}–${(bin + 1) * 15}°`, it); });
            } else if (groupMode === "brightness") {
                items.forEach(it => { const v = num(it.v_norm, null); add((v === null) ? "Unknown" : (v < 0.33 ? "Dark" : (v < 0.66 ? "Medium" : "Bright")), it); });
            } else if (groupMode === "saturation") {
                items.forEach(it => { const s = num(it.s_norm, null); add((s === null) ? "Unknown" : (s < 0.3 ? "Low" : (s < 0.7 ? "Medium" : "High")), it); });
            } else if (groupMode === "time") {
                items.forEach(it => { const t = Math.floor(num(it.start_ts, 0) / 10) * 10; add(`${t}–${t + 10}s`, it); });
            } else if (groupMode === "video") {
                items.forEach(it => { const vid = it.video_file || "Unknown"; const base = vid.replace(/\.[^.]+$/, ""); add(base, it); });
            }

            const g = $('#grid'); g.innerHTML = ''; let total = 0;

            if (groupMode === "video") {
                order.sort((a, b) => {
                    const aMax = Math.max(...keys[a].map(x => num(x.start_ts, 0)));
                    const bMax = Math.max(...keys[b].map(x => num(x.start_ts, 0)));
                    return bMax - aMax; // newest video first
                });
            } else {
                order.sort();
            }

            order.forEach(key => {
                const h = document.createElement('div');
                h.textContent = `${key} (${keys[key].length})`;
                h.style.cssText = "grid-column:1 / -1;margin:8px 0;font-weight:700;color:#c9d3e5";
                g.appendChild(h);
                keys[key].forEach(it => {
                    const gi = DATA.indexOf(it);
                    g.insertAdjacentHTML('beforeend', cardHTML(it, gi));
                    total++;
                });
            });
            wireTileClicks(0, g.querySelectorAll('.card').length);
            $('#countBadge').textContent = String(total);
            currentView = "grouped";
            updateNote();
            const sEl = $('#status'); if (sEl) sEl.textContent = '';
        }

        /* =========================
           Similar
           ========================= */
        function findSimilarByGlobalIndex(gi) {
            const tgt = DATA[gi];
            const TH = hueOf(tgt);
            const TS = num(tgt.s_norm, 0), TV = num(tgt.v_norm, 0);
            const tShape = (tgt.shape || 'other');
            const TA = num(tgt.area_norm, 0), TC = num(tgt.circ, 0);

            const sims = [];
            for (let i = 0; i < DATA.length; i++) {
                if (i === gi) continue;
                const it = DATA[i];
                let d = 0;

                const H = hueOf(it);
                if (Number.isFinite(TH) && Number.isFinite(H)) {
                    let dh = Math.abs(H - TH); dh = Math.min(dh, 360 - dh); d += (dh / 180);
                } else d += 1;

                d += Math.abs(num(it.s_norm, 0) - TS);
                d += Math.abs(num(it.v_norm, 0) - TV);
                d += Math.abs(num(it.area_norm, 0) - TA);
                d += Math.abs(num(it.circ, 0) - TC);
                if (tShape !== 'other' && (it.shape || 'other') !== 'other' && it.shape !== tShape) d += 2;

                sims.push({ i, d });
            }
            sims.sort((a, b) => a.d - b.d);
            const top = sims.slice(0, 30).map(s => s.i);

            CURRENT = [tgt, ...top.map(i => DATA[i])];
            CURRENT_IDX = [gi, ...top];
            currentView = "similar";
            startStreaming();
        }

        /* =========================
           Modal viewer & carousel
           ========================= */
        function seqIndicesForVideo(vf) {
            const arr = [];
            for (let i = 0; i < DATA.length; i++) {
                const it = DATA[i];
                if (it.video_file === vf) arr.push(i);
            }
            arr.sort((a, b) => num(DATA[a].start_ts, 0) - num(DATA[b].start_ts, 0));
            return arr;
        }

        function openModalAtGlobalIndex(gi, svg = false) {
            const it = DATA[gi];
            const seq = seqIndicesForVideo(it.video_file);

            // Respect collapse in modal sequence for browsing
            let seqCollapsed = [];
            if ($('#collapseDS').checked) {
                for (let i = 0; i < seq.length; i++) {
                    const a = DATA[seq[i]];
                    if (!isBlackTile(a)) { seqCollapsed.push(seq[i]); continue; }
                    let j = i;
                    while (j + 1 < seq.length) {
                        const b = DATA[seq[j + 1]];
                        if (!isBlackTile(b) || b.video_file !== a.video_file) break;
                        j++;
                    }
                    seqCollapsed.push(seq[i]); i = j;
                }
            } else {
                seqCollapsed = seq;
            }

            let pos = seqCollapsed.indexOf(gi);
            if (pos < 0) pos = 0;

            MODAL = { seq: seqCollapsed, pos, svg: !!svg };
            $('#modal').style.display = 'block';
            renderModal();
            renderModalSequence();
        }

        function closeModal() {
            $('#modal').style.display = 'none';
            MODAL = null;
            $('#viewer').innerHTML = '';
            $('#carousel').innerHTML = '';
        }

        $('#modalClose').addEventListener('click', closeModal);
        $('#modalPrev').addEventListener('click', () => { if (!MODAL) return; MODAL.pos = Math.max(0, MODAL.pos - 1); renderModal(); highlightCarousel(); });
        $('#modalNext').addEventListener('click', () => { if (!MODAL) return; MODAL.pos = Math.min(MODAL.seq.length - 1, MODAL.pos + 1); renderModal(); highlightCarousel(); });
        $('#modalSvgToggle').addEventListener('input', (e) => { if (!MODAL) return; MODAL.svg = !!e.target.checked; renderModal(); renderModalSequence(); });

        const STYLE_ALIASES = {
            default: ["", "_outline", "_smooth", "_bezier", "_skeleton", "_rings", "_hull", "_edges", "_ellipse", "_contour", "_convex"],
            outline: ["_outline", "_contour"],
            smooth: ["_smooth"],
            bezier: ["_bezier"],
            skeleton: ["_skeleton"],
            rings: ["_rings"],
            hull: ["_hull", "_convex"],
            edges: ["_edges"],
            ellipse: ["_ellipse"]
        };

        function svgTriesFor(it) {
            // Use the active style list; "" means the plain filename without style suffix
            const styles = STYLE_ALIASES[svgStyle] || STYLE_ALIASES.default;

            // Derive the base name (without extension) from csv 'svg' or thumb filenames
            let base = null;
            if (it.svg) base = it.svg.replace(/\.[^.]+$/, "");
            else if (it.thumb_obj) base = it.thumb_obj.replace(/_obj\.jpg$/i, "");
            else if (it.thumb) base = it.thumb.replace(/\.jpg$/i, "");

            // Build candidate "roots" to try, in this order:
            //  1) base_obj, 2) base_obj_hybrid, 3) base, 4) (if csv included a different exact name) csvBase
            const roots = [];
            const addRoot = r => { if (r && !roots.includes(r)) roots.push(r); };

            if (base) {
                addRoot(`${base}_obj`);
                addRoot(`${base}_obj_hybrid`);
                addRoot(base);
            }
            if (it.svg) {
                const csvBase = it.svg.replace(/\.[^.]+$/, "");
                addRoot(csvBase);
            }

            // Create the try list:
            // For each root, try <root><style>.svg and .SVG (case variants);
            // style "" produces the plain root.svg/root.SVG
            const tries = [];
            for (const root of roots) {
                for (const suf of styles) {
                    const name = (suf === "") ? root : (root + suf);
                    tries.push(`svgs/${encodeURIComponent(name)}.svg`);
                    tries.push(`svgs/${encodeURIComponent(name)}.SVG`);
                }
            }

            return tries;
        }

        async function renderModal() {
            if (!MODAL) return;
            const gi = MODAL.seq[MODAL.pos]; const it = DATA[gi];
            $('#modalSeries').textContent = it.video_file || '–';
            $('#modalPos').textContent = String(MODAL.pos + 1);
            $('#modalLen').textContent = String(MODAL.seq.length);
            const st = num(it.start_ts, 0).toFixed(2), en = num(it.end_ts, st + 1 / 30).toFixed(2);
            $('#modalTime').textContent = `${st}–${en}s`;

            const viewer = $('#viewer'); viewer.innerHTML = '';

            if (MODAL.svg) {
                const tries = svgTriesFor(it);
                let ok = false;
                for (const url of tries) {
                    try {
                        const txt = await fetch(url).then(r => r.ok ? r.text() : Promise.reject());
                        const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(txt);
                        const img = new Image(); img.src = dataUrl; await img.decode();
                        viewer.appendChild(img); ok = true;
                        $('#dlImg').href = dataUrl;
                        $('#dlImg').download = (it.svg || 'image.svg');
                        $('#dlImg').onclick = (e) => { if (!allowDownload('svg')) e.preventDefault(); else recordDownload('svg'); };
                        break;
                    } catch (e) { }
                }
                if (!ok) {
                    const p = document.createElement('div'); p.className = 'small'; p.textContent = 'SVG missing for this frame.'; viewer.appendChild(p);
                    $('#dlImg').removeAttribute('href');
                    $('#dlImg').onclick = null;
                }
                $('#modalSvgToggle').checked = true;
            } else {
                const url = thumbUrlFor(it);
                const img = new Image(); img.src = url;
                viewer.appendChild(img);
                const fname = (thumbMode === 'object' ? it.thumb_obj : it.thumb) || 'image.png';
                $('#dlImg').href = url;
                $('#dlImg').download = fname;
                $('#dlImg').onclick = (e) => { if (!allowDownload('image')) e.preventDefault(); else recordDownload('image'); };
                $('#modalSvgToggle').checked = false;
            }

            $('#modalMeta').innerHTML =
                `<div><strong>${it.video_file || ''}</strong></div>` +
                `<div>t=${(+it.start_ts).toFixed(2)}–${(+it.end_ts).toFixed(2)}s</div>` +
                `<div>HSV: h=${Number.isFinite(num(it.h_norm, NaN)) ? num(it.h_norm).toFixed(2) : '–'} s=${num(it.s_norm, 0).toFixed(2)} v=${num(it.v_norm, 0).toFixed(2)}</div>`;
        }

        function renderModalSequence() {
            if (!MODAL) return;
            const car = $('#carousel'); car.innerHTML = '';
            const frag = document.createDocumentFragment();
            for (let i = 0; i < MODAL.seq.length; i++) {
                const gi = MODAL.seq[i]; const it = DATA[gi];
                const url = thumbUrlFor(it);
                const img = document.createElement('img');
                img.className = 'carousel-thumb';
                img.src = url;
                img.title = `${num(it.start_ts, 0).toFixed(2)}–${num(it.end_ts).toFixed(2)}s`;
                img.addEventListener('click', () => { MODAL.pos = i; renderModal(); highlightCarousel(); });
                frag.appendChild(img);
            }
            car.appendChild(frag);
            highlightCarousel();
        }

        function highlightCarousel() {
            if (!MODAL) return;
            const thumbs = $$('#carousel img.carousel-thumb');
            thumbs.forEach((el, i) => el.classList.toggle('selected', i === MODAL.pos));
        }

        /* =========================
           Video download (MP4)
           ========================= */
        let _ffmpeg = null, _ffmpegLoading = null;
        async function loadFFmpeg() {
            if (_ffmpeg) return _ffmpeg;
            if (_ffmpegLoading) return _ffmpegLoading;
            _ffmpegLoading = new Promise((resolve, reject) => {
                const loadScript = () => {
                    const s = document.createElement('script');
                    s.src = "https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/umd/ffmpeg.min.js";
                    s.onload = async () => {
                        try {
                            const { createFFmpeg } = FFmpeg;
                            const ff = createFFmpeg({
                                log: false,
                                corePath: 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/umd/ffmpeg-core.js'
                            });
                            await ff.load();
                            _ffmpeg = ff;
                            resolve(ff);
                        } catch (e) {
                            reject(e);
                        }
                    };
                    s.onerror = reject;
                    document.head.appendChild(s);
                };

                if (window.FFmpeg) {
                    try {
                        const { createFFmpeg } = window.FFmpeg;
                        const ff = createFFmpeg({
                            log: false,
                            corePath: 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/umd/ffmpeg-core.js'
                        });
                        ff.load().then(() => {
                            _ffmpeg = ff;
                            resolve(ff);
                        }).catch(reject);
                    } catch (e) {
                        loadScript();
                    }
                } else {
                    loadScript();
                }
            });
            return _ffmpegLoading;
        }

        /* =========================
   Full video download
   ========================= */
        function getFullVideoName(objectId) {
            // Legacy pattern, if objectId looks like "..._e000_000300_obj"
            if (objectId && typeof objectId === 'string') {
                const m = objectId.match(/^(.+?)_e\d+_\d+_obj$/);
                if (m) return m[1] + '.mp4';
                // If the id matches a row, use its video_file
                const row = (typeof DATA !== 'undefined') ? DATA.find(r => r.id === objectId) : null;
                if (row) return normalizeVideoFileName(row.video_file);
            }
            // Fallback to the currently selected row in the modal
            const gi = MODAL?.seq?.[MODAL?.pos];
            const row2 = Number.isInteger(gi) ? DATA[gi] : null;
            return normalizeVideoFileName(row2?.video_file);
        }

        async function downloadFullVideo(objectId) {
            const fullVideoName = getFullVideoName(objectId);
            if (!fullVideoName) {
                alert('Full video not available for this object');
                return;
            }
            // Ask Netlify to mint a short-lived R2 URL
            const res = await fetch(`/.netlify/functions/get-r2-url?file=${encodeURIComponent(fullVideoName)}`);
            if (!res.ok) {
                const msg = await res.text().catch(() => '');
                throw new Error(`Failed to fetch presigned URL (${res.status}) ${msg}`);
            }
            const { url } = await res.json();
            const a = document.createElement('a');
            a.href = url;
            a.download = fullVideoName;
            a.rel = 'noopener';
            document.body.appendChild(a);
            a.click();
            a.remove();
        }


        function tileDurationMs(row) {
            const st = num(row.start_ts, null), et = num(row.end_ts, null);
            if (st !== null && et !== null && et > st) return Math.round((et - st) * 1000);
            return 33; // ~30fps
        }

        function loadImageOnce(url) {
            return new Promise((res, rej) => {
                const img = new Image(); img.crossOrigin = 'anonymous';
                img.onload = () => res(img); img.onerror = rej; img.src = url;
            });
        }
        async function rasterizeSvgToImage(it) {
            const tries = svgTriesFor(it);
            for (const url of tries) {
                try {
                    const text = await fetch(url).then(r => r.ok ? r.text() : Promise.reject());
                    const data = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(text);
                    const img = await loadImageOnce(data);
                    return img;
                } catch (e) { }
            }
            throw new Error('Missing SVG for one or more frames.');
        }

        async function buildFramesForCurrentSequence() {
            if (!MODAL || !Array.isArray(MODAL.seq) || MODAL.seq.length === 0) throw new Error('No sequence frames.');
            const useSvg = !!MODAL.svg;
            const preferObj = !useSvg && thumbMode === 'object';
            const seq = MODAL.seq.map(gi => DATA[gi]);

            const frames = [];
            for (let i = 0; i < seq.length; i++) {
                const it = seq[i];
                let img;
                if (useSvg) {
                    img = await rasterizeSvgToImage(it);
                } else {
                    let src = null;
                    if (preferObj && it.thumb_obj) src = `thumbs_obj/${it.thumb_obj}`;
                    else if (it.thumb) src = `thumbs/${it.thumb}`;
                    else if (it.thumb_obj) src = `thumbs_obj/${it.thumb_obj}`;

                    if (!src) {
                        // Synthesize black frame
                        const c = document.createElement('canvas'); c.width = c.height = 512;
                        const ctx = c.getContext('2d'); ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 512, 512);
                        img = await loadImageOnce(c.toDataURL('image/png'));
                    } else {
                        img = await loadImageOnce(src);
                    }
                }
                const curStart = num(it.start_ts, 0);
                const nextStart = (i < seq.length - 1) ? num(seq[i + 1].start_ts, NaN) : NaN;
                let dt = Number.isFinite(nextStart) ? (nextStart - curStart) : (num(it.end_ts, curStart + 1 / 30) - curStart);
                if (!Number.isFinite(dt) || dt <= 0) dt = 1 / 30;
                const repeats = Math.max(1, Math.round(dt * 30));
                frames.push({ img, repeats });
            }
            return frames;
        }

        async function encodeMp4FromFrames(frames) {
            const ffmpeg = await loadFFmpeg();
            const canvas = document.createElement('canvas');
            const VIDEO_SIDE = 512;
            canvas.width = VIDEO_SIDE; canvas.height = VIDEO_SIDE;
            const ctx = canvas.getContext('2d');

            let idx = 0;
            for (const { img, repeats } of frames) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, VIDEO_SIDE, VIDEO_SIDE);
                const scale = Math.min(VIDEO_SIDE / img.width, VIDEO_SIDE / img.height);
                const w = Math.round(img.width * scale);
                const h = Math.round(img.height * scale);
                const x = Math.floor((VIDEO_SIDE - w) / 2);
                const y = Math.floor((VIDEO_SIDE - h) / 2);
                ctx.drawImage(img, x, y, w, h);

                const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
                const buf = new Uint8Array(await blob.arrayBuffer());

                for (let r = 0; r < repeats; r++) {
                    const name = `f${String(++idx).padStart(5, '0')}.png`;
                    ffmpeg.FS('writeFile', name, buf);
                }
            }

            const out = 'out.mp4';
            await ffmpeg.run(
                '-framerate', '30',
                '-i', 'f%05d.png',
                '-c:v', 'libx264',
                '-pix_fmt', 'yuv420p',
                '-movflags', '+faststart',
                out
            );

            const data = ffmpeg.FS('readFile', out);

            // Clean up
            try {
                for (let i = 1; i <= idx; i++) {
                    const name = `f${String(i).padStart(5, '0')}.png`;
                    try { ffmpeg.FS('unlink', name); } catch { }
                }
                ffmpeg.FS('unlink', out);
            } catch { }

            // Create blob from the Uint8Array directly
            return new Blob([data], { type: 'video/mp4' });
        }

        async function onDownloadVideoClick() {
            try {
                if (!MODAL) { alert('No video sequence loaded.'); return; }

                // *** FIX: pull the id from the current modal frame ***
                const objectId = getCurrentObjectIdFromModal();
                if (objectId) {
                    await downloadFullVideo(objectId);   // uses Netlify presign -> R2
                    return;                               // done — skip the fallback
                }

                // If we get here, continue with the original FFmpeg-based code
                console.log('Falling back to FFmpeg video generation');

        // ... rest of your existing FFmpeg code continues here ...

                const useSvg = !!MODAL.svg;
                const bucket = useSvg ? 'svg' : 'image';
                console.log('Using SVG:', useSvg, 'Bucket:', bucket);

                if (!isPro()) {
                    const used = getDL(bucket);
                    if ((used + 2) > FREE_LIMIT) {
                        showProModal();
                        alert(`That download exceeds your free ${bucket.toUpperCase()} allowance. Please upgrade to Pro.`);
                        return;
                    }
                    const ok = confirm(`This video will use 2 of your free ${bucket.toUpperCase()} downloads.\nYou have ${FREE_LIMIT - used} remaining.\nContinue?`);
                    if (!ok) return;
                }

                $('#status').textContent = 'Loading video encoder…';
                console.log('About to load FFmpeg...');

                // Make sure FFmpeg loads
                await loadFFmpeg();
                console.log('FFmpeg loaded successfully');

                $('#status').textContent = 'Preparing video frames…';
                console.log('Building frames...');

                const frames = await buildFramesForCurrentSequence();
                console.log('Frames built:', frames.length);

                if (!frames || frames.length === 0) {
                    throw new Error('No frames to encode');
                }

                $('#status').textContent = `Encoding ${frames.reduce((sum, f) => sum + f.repeats, 0)} frames to MP4…`;
                const blob = await encodeMp4FromFrames(frames);

                const a = document.createElement('a');
                a.download = 'carousel.mp4';
                a.href = URL.createObjectURL(blob);
                a.click();
                URL.revokeObjectURL(a.href);

                recordVideoDownload(bucket);

                if (!isPro()) {
                    if (confirm("Upgrade to Pro for unlimited downloads?")) {
                        showProModal();
                    } else if (confirm("Would you like to make a donation instead?")) {
                        const d = $('#donateBtn');
                        if (d) d.click();
                    }
                }

                $('#status').textContent = 'Video saved!';
                setTimeout(() => { $('#status').textContent = ''; }, 3000);

            } catch (e) {
                console.error('Video generation error:', e);
                console.error('Error stack:', e.stack);
                console.error('Error message:', e.message);
                alert('Could not generate video: ' + (e.message || e.toString()));
                $('#status').textContent = '';
            }
        }

        $('#dlVideo').addEventListener('click', onDownloadVideoClick);

        /* =========================
           Wire UI
           ========================= */
        $('#sizeRange').addEventListener('input', (e) => {
            document.documentElement.style.setProperty('--thumb', e.target.value + 'px');
        });
        $('#groupSelect').addEventListener('input', (e) => { groupMode = e.target.value; refresh(); });
        $('#thumbMode').addEventListener('input', (e) => { thumbMode = e.target.value; refresh(); });
        $('#sortSelect').addEventListener('input', (e) => {
            const v = e.target.value;
            if ((v === 'hueRange_pro' || v === 'sharpArea_pro') && !isPro()) {
                showProModal();
                $('#sortSelect').value = sortMode;
                return;
            }
            sortMode = v; refresh();
        });
        $('#sortDirBtn').addEventListener('click', () => {
            sortAsc = !sortAsc; $('#sortDirBtn').textContent = sortAsc ? '↑' : '↓'; refresh();
        });
        ['imgOnly', 'hideDup', 'collapseDS'].forEach(id => {
            const el = $('#' + id); if (el) el.addEventListener('input', refresh);
        });
        $('#search').addEventListener('input', () => { refresh(); });
        $('#svgStyle').addEventListener('input', () => { svgStyle = $('#svgStyle').value; });

        // Advanced filter events
        function updateHueRange() {
            const minVal = parseInt($("#hmin").value, 10), maxVal = parseInt($("#hmax").value, 10);
            $('#hbadge').textContent = `${minVal}°–${maxVal}°`;
        }
        $('#hmin').addEventListener('input', () => {
            const minVal = parseInt($('#hmin').value, 10), maxVal = parseInt($('#hmax').value, 10);
            if (minVal > maxVal) $('#hmax').value = String(minVal);
            updateHueRange(); refresh();
        });
        $('#hmax').addEventListener('input', () => {
            const minVal = parseInt($('#hmin').value, 10), maxVal = parseInt($('#hmax').value, 10);
            if (maxVal < minVal) $('#hmin').value = String(maxVal);
            updateHueRange(); refresh();
        });
        $('#motionTier').addEventListener('input', refresh);

        $('#resetBtn').addEventListener('click', () => {
            $('#sizeRange').value = 240; document.documentElement.style.setProperty('--thumb', '240px');
            $('#groupSelect').value = 'video'; groupMode = 'video';
            if (!document.querySelector('#sortSelect option[value="start_ts"]')) {
                $("#sortSelect").insertAdjacentHTML('beforeend', '<option value="start_ts">Start time</option>');
            }
            $('#sortSelect').value = 'start_ts'; sortMode = 'start_ts'; sortAsc = false; $('#sortDirBtn').textContent = '↓';
            $('#thumbMode').value = 'object'; thumbMode = 'object';
            $('#imgOnly').checked = true; $('#hideDup').checked = false;
            $('#collapseDS').checked = false;
            $('#search').value = '';
            $('#hmin').value = 3; $('#hmax').value = 360; updateHueRange();

            buildShapeCheckboxes();
            buildColorChips();

            refresh();
        });

        $('#upgradeBtn').addEventListener('click', () => showProModal());
        $('#closePro').addEventListener('click', () => hideProModal());
        $('#iPaid').addEventListener('click', () => {
            const code = prompt('Enter your upgrade code:');
            if (!code) return; // User cancelled
            if (code === '4EverJung') {
                setPro();
                hideProModal();
                alert('Pro mode activated!');
            } else {
                alert('Invalid code');
            }
        });

        window.addEventListener('click', (e) => {
            if (e.target === $('#proModal')) hideProModal();
        });

        /* =========================
   Visitors badge (optional)
   ========================= */
        (function visitors() {
            function getOrSetUID() {
                try {
                    let id = localStorage.getItem('uap_uid');
                    if (!id) {
                        id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).slice(2);
                        localStorage.setItem('uap_uid', id);
                        document.cookie = 'uap_uid=' + id + '; Path=/; Max-Age=' + (60 * 60 * 24 * 730);
                    }
                    return id;
                }
                catch (e) {
                    const m = document.cookie.match(/(?:^|;\s*)uap_uid=([^;]+)/);
                    if (m) return m[1];
                    const id = Math.random().toString(36).slice(2);
                    document.cookie = 'uap_uid=' + id + '; Path=/; Max-Age=' + (60 * 60 * 24 * 730);
                    return id;
                }
            }

            async function postJSON(url, payload) {
                try {
                    const res = await fetch(url, {
                        method: 'POST',
                        headers: { 'content-type': 'application/json' },
                        body: JSON.stringify(payload),
                        credentials: 'same-origin'
                    });
                    if (!res.ok) throw new Error('HTTP ' + res.status);
                    return res.json();
                } catch (e) {
                    // Silently fail for 404s
                    return null;
                }
            }

            async function updateVisitorsBadge() {
                const el = document.getElementById('visitorsBadge');
                if (!el) return;

                try {
                    const uid = getOrSetUID();
                    const endpoints = ['/api/unique', '/.netlify/functions/unique'];

                    for (const url of endpoints) {
                        try {
                            const result = await postJSON(url, { visitorId: uid });
                            if (result && Number.isFinite(result.total)) {
                                el.textContent = result.total + ' visitors';
                                return;
                            }
                        } catch (e) {
                            // Continue to next endpoint
                        }
                    }

                    // If all endpoints fail, just hide the badge
                    el.style.display = 'none';
                } catch (e) {
                    // If anything fails, hide the badge
                    el.style.display = 'none';
                }
            }

            // Don't let visitor tracking errors affect the rest of the app
            setTimeout(() => {
                updateVisitorsBadge().catch(() => {
                    const el = document.getElementById('visitorsBadge');
                    if (el) el.style.display = 'none';
                });
            }, 100);
        })();

        /* =========================
           Shape checkboxes & color chips
           ========================= */
        function buildShapeCheckboxes() {
            const box = $("#shapeBox"); if (!box) return; box.innerHTML = "";
            const counts = new Map(); DATA.forEach(it => counts.set(it.shape, (counts.get(it.shape) || 0) + 1));
            const top = [...counts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 10).map(x => x[0]);
            const shapes = new Set(top.concat(["other"]));
            shapes.forEach(sh => {
                const id = "shape-" + sh.replace(/\s+/g, "_");
                const cb = document.createElement("input");
                cb.type = "checkbox"; cb.id = id; cb.checked = true; cb.dataset.shape = sh; cb.addEventListener("change", refresh);
                const lbl = document.createElement("label");
                lbl.htmlFor = id; lbl.style.marginRight = "10px";
                lbl.appendChild(cb); lbl.appendChild(document.createTextNode(" " + sh));
                box.appendChild(lbl);
            });
        }

        function buildColorChips() {
            const wrap = $("#colorChips"); if (!wrap) return; wrap.innerHTML = "";
            const colors = new Set(DATA.map(colorGroup));
            colors.forEach(c => {
                const b = document.createElement("div");
                b.className = "chip"; b.title = c; b.dataset.color = c;
                b.style.background = (c === "White" || c === "Gray" || c === "Black") ? c.toLowerCase() : c;
                b.addEventListener("click", () => { b.classList.toggle("sel"); refresh(); });
                wrap.appendChild(b);
            });
        }

        /* =========================
           Refresh pipeline
           ========================= */
        function refresh() {
            const sz = parseInt($("#sizeRange")?.value || "240", 10);
            document.documentElement.style.setProperty("--thumb", (isFinite(sz) ? sz : 240) + "px");
            applyFilters();
            updateNote();
            if (groupMode === "none") { currentView = "all"; startStreaming(); } else { groupAndRender(CURRENT); }
        }

        /* =========================
           Boot
           ========================= */
        (async function boot() {
            try {
                updateBadges();
                // defaults
                groupMode = 'video';
                sortMode = 'start_ts';
                sortAsc = false;
                thumbMode = 'object';
                $('#groupSelect').value = 'video';
                if (!document.querySelector('#sortSelect option[value="start_ts"]')) {
                    $("#sortSelect").insertAdjacentHTML('beforeend', '<option value="start_ts">Start time</option>');
                }
                $('#sortSelect').value = 'start_ts';
                $('#sortDirBtn').textContent = '↓';
                $('#thumbMode').value = 'object';
                $('#hmin').value = 3; $('#hmax').value = 360; updateHueRange();

                $('#status').textContent = 'Loading atlas…';
                await loadCSV();

                // annotate motion tiers roughly based on numeric motion or keywords
                const mvals = DATA.map(it => num(it.motion, null)).filter(v => v !== null);
                const pct = (values, p) => {
                    if (!values.length) return 0;
                    const a = [...values].sort((x, y) => x - y);
                    const i = Math.floor(p * (a.length - 1));
                    return a[i];
                };
                const t1 = pct(mvals, 0.33), t2 = pct(mvals, 0.66);
                DATA.forEach(it => {
                    const mv = num(it.motion, null);
                    it.motionTier = (mv === null)
                        ? ((String(it.motion || '').toLowerCase().includes('fast')) ? 'high' : (String(it.motion || '').toLowerCase().includes('drift') ? 'med' : 'low'))
                        : (mv <= t1 ? 'low' : (mv <= t2 ? 'med' : 'high'));
                });

                dedupeByVideoClusters();
                buildShapeCheckboxes();
                buildColorChips();

                $('#status').textContent = '';
                refresh();
            } catch (e) {
                console.error(e);
                $('#note').textContent = 'Failed to load atlas.csv';
            }
        })();
    </script>
</body>
</html>