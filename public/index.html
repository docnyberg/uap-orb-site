<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>UAP / Orb Atlas Viewer</title>

    <style>
        :root {
            --bg: #0b0d12;
            --fg: #e7eaf0;
            --muted: #9aa3b2;
            --card: #131722;
            --border: #243041;
            --chip: #1c2330;
            --acc: #9bd1ff;
            --thumb: 240px;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 16px;
            background: var(--bg);
            color: var(--fg);
            font: 14px system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif
        }

        h1 {
            font-size: 18px;
            margin: 0 10px 8px 0
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            background: var(--chip);
            border-radius: 999px;
            font-size: 11px;
            color: #c9d3e5;
            margin-left: 8px
        }

        .codebook-sidebar {
            position: fixed;
            top: 86px;
            right: 16px;
            width: 260px;
            max-height: calc(100vh - 120px);
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
            z-index: 30;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform .25s ease, opacity .2s ease;
        }

        .codebook-sidebar.collapsed {
            transform: translateX(calc(100% + 24px));
            opacity: 0;
            pointer-events: none;
        }

        .codebook-sidebar .sidebar-header {
            position: sticky;
            top: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px;
            background: var(--card);
            border-bottom: 1px solid var(--border);
            z-index: 1;
        }

        .codebook-sidebar .sidebar-title {
            font-weight: 600;
            font-size: 14px;
            letter-spacing: .04em;
            text-transform: uppercase;
        }

        .codebook-sidebar .sidebar-subtitle {
            display: block;
            margin-top: 2px;
            font-size: 11px;
            color: var(--muted);
        }

        .codebook-sidebar .sidebar-body {
            padding: 10px;
            overflow-y: auto;
            display: grid;
            gap: 8px;
        }

        .codebook-entry {
            display: grid;
            grid-template-columns: 56px 1fr;
            gap: 10px;
            align-items: center;
            width: 100%;
            padding: 6px;
            background: var(--chip);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: inherit;
            text-align: left;
            cursor: pointer;
            transition: border-color .15s ease, transform .15s ease;
        }

        .codebook-entry:hover {
            border-color: #395072;
            transform: translateY(-1px);
        }

        .codebook-entry.busy {
            opacity: .6;
            pointer-events: none;
        }

        .codebook-entry .preview {
            width: 56px;
            height: 56px;
            border-radius: 8px;
            overflow: hidden;
            background: #05070b;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .codebook-entry .preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .codebook-entry .preview .missing-thumb {
            font-size: 11px;
            color: var(--muted);
            text-align: center;
            padding: 6px;
        }

        .codebook-entry .info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .codebook-entry .info strong {
            font-size: 12px;
            letter-spacing: .02em;
        }

        .codebook-entry .info small {
            font-size: 11px;
            color: var(--muted);
        }

        .sidebar-empty {
            padding: 12px;
            font-size: 12px;
            color: var(--muted);
            text-align: center;
        }

        .sidebar-drop {
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--muted);
            cursor: pointer;
            font-size: 11px;
            letter-spacing: .04em;
            text-transform: uppercase;
        }

        .sidebar-drop:hover {
            color: var(--fg);
            border-color: #395072;
        }

        #codebookToggle {
            position: fixed;
            right: 16px;
            bottom: 20px;
            display: none;
            padding: 10px 14px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--fg);
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 30;
        }

        #codebookToggle:hover {
            border-color: #395072;
        }

        .codebook-sidebar.collapsed + #codebookToggle {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        @media (max-width: 900px) {
            .codebook-sidebar {
                width: min(90vw, 260px);
                top: auto;
                bottom: 80px;
            }
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin: 10px 0
        }

        .group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 8px 10px
        }

        select, input[type="range"], button {
            font: inherit
        }

        input[type="text"] {
            padding: 8px 10px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--fg);
            border-radius: 10px;
            min-width: 260px
        }

        select {
            padding: 7px 10px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--fg);
            border-radius: 10px
        }

        button {
            padding: 8px 10px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--fg);
            border-radius: 10px;
            cursor: pointer
        }

            button:hover {
                border-color: #395072
            }

        .drawer {
            margin: 10px 0
        }

        details {
            border: 1px solid var(--border);
            border-radius: 10px;
            background: var(--card)
        }

        summary {
            cursor: pointer;
            padding: 8px 12px;
            color: #c9d3e5
        }

        details .inner {
            padding: 8px 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: baseline
        }

        .chips {
            display: flex;
            gap: 6px;
            flex-wrap: wrap
        }

        .chip {
            width: 22px;
            height: 16px;
            border-radius: 5px;
            border: 1px solid var(--border);
            cursor: pointer
        }

            .chip.sel {
                outline: 2px solid #fff5
            }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill,minmax(var(--thumb),1fr));
            gap: 12px
        }

        .card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
            position: relative
        }

        .swatch {
            height: 18px
        }

        .thumb-wrap {
            width: 100%;
            aspect-ratio: 1/1;
            overflow: hidden;
            background: #000
        }

        .thumb {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            display: block
        }

        .meta {
            padding: 10px;
            color: #c9d3e5;
            font-size: 12px;
            line-height: 1.35
        }

        .kv {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            margin: 2px 0
        }

            .kv code {
                background: var(--chip);
                padding: 0 6px;
                border-radius: 6px
            }

        .actions {
            position: absolute;
            top: 6px;
            right: 6px;
            display: flex;
            gap: 6px
        }

        .btn-mini {
            background: #0008;
            border: 1px solid #7688a3;
            color: #fff;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 6px
        }

        /* Modal */
        .overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: #000a;
            z-index: 50
        }

        .modal {
            max-width: 92vw;
            max-height: 92vh;
            margin: 4vh auto;
            background: #0f1420;
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: auto;
            position: relative;
            padding: 10px
        }

            .modal img {
                max-width: 100%;
                height: auto;
                background: #000;
                border-radius: 8px
            }

            .modal .close {
                position: absolute;
                top: 8px;
                right: 8px
            }
        .modal-extras {
            margin-top: 6px;
            color: var(--muted);
            font-size: 12px;
            line-height: 1.4
        }

            .modal-extras div + div {
                margin-top: 2px
            }

        .thumb.watermark { /* flagged; effect under .hideTTActive */
        }

        .hideTTActive .thumb.watermark {
            transform: scale(1.2);
            transform-origin: center
        }

        /* Modal sequence controls & carousel (from your current file) */
        .modal-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0 6px 0;
            flex-wrap: wrap
        }

            .modal-controls .spacer {
                flex: 1
            }

            .modal-controls .toggle {
                display: flex;
                align-items: center;
                gap: 6px;
                font-size: 12px;
                color: var(--muted)
            }

            .modal-controls .nav {
                display: flex;
                gap: 6px
            }

                .modal-controls .nav button {
                    background: #0008;
                    border: 1px solid #7688a3;
                    color: #fff;
                    font-size: 12px;
                    padding: 4px 8px;
                    border-radius: 6px
                }

        .modal-carousel {
            display: flex;
            gap: 4px;
            overflow-x: auto;
            padding: 6px 2px;
            border-top: 1px dashed var(--border);
            border-bottom: 1px dashed var(--border);
            scroll-snap-type: x mandatory
        }

            .modal-carousel img.carousel-thumb {
                height: 80px;
                flex: 0 0 auto;
                object-fit: cover;
                border-radius: 6px;
                border: 2px solid transparent;
                background: #000;
                scroll-snap-align: center
            }

                .modal-carousel img.carousel-thumb.selected {
                    border-color: #58a6ff;
                    box-shadow: 0 0 0 2px rgba(88,166,255,.25)
                }

                .modal-carousel img.carousel-thumb.wm {
                    opacity: .55;
                    filter: grayscale(.2)
                }

        @media (max-width:700px) {
            .modal-carousel img.carousel-thumb {
                height: 64px
            }
        }

        /* Monetization / Pro UI */
        .pill {
            padding: 6px 10px;
            border: 1px solid var(--border);
            background: var(--card);
            color: var(--fg);
            border-radius: 999px;
            cursor: pointer;
            margin-left: 6px
        }

            .pill:hover {
                border-color: #395072
            }

        .overlay-lite {
            position: fixed;
            inset: 0;
            background: #000a;
            display: none;
            z-index: 100
        }

        .modal-lite {
            max-width: 560px;
            margin: 8vh auto;
            background: #0f1420;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 16px;
            color: #c9d3e5
        }

            .modal-lite h3 {
                margin: 0 0 8px 0
            }

            .modal-lite .row {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
                margin-top: 12px
            }

            .modal-lite .btn {
                padding: 8px 10px;
                border: 1px solid var(--border);
                border-radius: 8px;
                cursor: pointer;
                background: var(--card);
                color: var(--fg)
            }

                .modal-lite .btn.primary {
                    border-color: #6fb5ff
                }

        .muted {
            color: #9aa3b2
        }
    </style>

    <!-- PapaParse -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
    <header style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
        <h1>UAP / Orb Atlas Viewer</h1>
        <span id="countBadge" class="badge" data-count="0">0 items</span>
        <span id="visitorsBadge" class="badge">— visitors</span>
        <span id="note" class="badge">View: All • Sort: Hue ↑</span>
        <!-- NEW: monetization buttons -->
        <span style="flex:1"></span>
        <button id="upgradeBtn" class="pill" title="Upgrade to Pro">Upgrade</button>
        <button id="donateBtn" class="pill" title="Donate">Donate</button>
    </header>

    <aside id="codebookSidebar" class="codebook-sidebar" tabindex="-1">
        <div class="sidebar-header">
            <div>
                <div class="sidebar-title">Symbol Codebook</div>
                <span class="sidebar-subtitle">Cluster prototypes</span>
            </div>
            <button id="codebookDrop" class="sidebar-drop" type="button">Drop</button>
        </div>
        <div class="sidebar-body">
            <div class="sidebar-empty">Loading codebook…</div>
        </div>
    </aside>
    <button id="codebookToggle" class="codebook-toggle" type="button">Codebook</button>

    <div class="controls">
        <div class="group">
            <label for="sizeRange">Tile size</label>
            <input id="sizeRange" type="range" min="140" max="420" value="240">
        </div>

        <div class="group">
            <label for="groupSelect">Group by</label>
            <select id="groupSelect">
                <option value="none" selected>None (All)</option>
                <option value="hue">Hue</option>
                <option value="brightness">Brightness</option>
                <option value="saturation">Saturation</option>
                <option value="time">Time</option>
                <option value="video">Source Video</option>
            </select>
        </div>

        <div class="group">
            <label for="sortSelect">Sort by</label>
            <select id="sortSelect">
                <option value="hue" selected>Hue</option>
                <option value="saturation">Saturation</option>
                <option value="brightness">Brightness</option>
                <option value="sharpness">Sharpness</option>
                <option value="area">Area</option>
                <option value="hueRange">ΔHue</option>
                <!-- Pro-visible, gated options -->
                <option value="hueRange_pro">ΔHue (Pro)</option>
                <option value="sharpArea_pro">Sharpness × Area (Pro)</option>
            </select>
            <button id="sortDirBtn" title="Toggle sort direction">↑</button>
        </div>

        <div class="group">
            <label for="thumbMode">Thumbs</label>
            <select id="thumbMode">
                <option value="object" selected>Object</option>
                <option value="scene">Scene</option>
            </select>
        </div>

        <div class="group">
            <label for="svgStyle">SVG style</label>
            <select id="svgStyle">
                <option value="default" selected>Default</option>
                <option value="outline">Outline</option>
                <option value="smooth">Smooth</option>
                <option value="bezier">Bézier</option>
                <option value="skeleton">Skeleton</option>
                <option value="rings">Rings</option>
                <option value="hull">Hull</option>
                <option value="edges">Edges</option>
                <option value="ellipse">Ellipse</option>
            </select>
        </div>

        <div class="group">
            <input type="checkbox" id="imgOnly" checked><label for="imgOnly">Images only</label>
            <input type="checkbox" id="hideDup"><label for="hideDup">Hide duplicates</label>
            <input type="checkbox" id="hideTT"><label for="hideTT">Hide TikTok watermarks</label>
        </div>

        <div class="group">
            <label for="hmin">Hue</label>
            <input type="range" id="hmin" min="0" max="360" value="3">
            <input type="range" id="hmax" min="0" max="360" value="360">
            <span id="hbadge" class="badge">3°–360°</span>
        </div>

        <input id="search" type="text" placeholder="Search json/video/hex…">
        <button id="resetBtn">Reset</button>
    </div>

    <div class="drawer">
        <details id="advanced">
            <summary>Advanced filters (shapes, motion tier, color groups)</summary>
            <div class="inner">
                <div>
                    <label>
                        <strong title="Objects grouped by relative motion; Low/Med/High indicates how much the object moved (speed/trajectory) compared to others.">Motion tier:</strong>
                        <select id="motionTier">
                            <option value="any" selected>Any</option>
                            <option value="low">Low</option>
                            <option value="med">Medium</option>
                            <option value="high">High</option>
                        </select>
                    </label>
                </div>
                <div id="shapeBox" style="display:flex;gap:12px;flex-wrap:wrap"></div>
                <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                    <strong title="Filter by major color category of the object (based on hue & saturation).">Color:</strong>
                    <div id="colorChips" class="chips"></div>
                </div>
            </div>
        </details>
    </div>

    <div id="status" style="margin:8px 0 10px 0;font-weight:600"></div>
    <div id="grid" class="grid"></div>
    <div id="sentinel" style="height:1px"></div>

    <!-- Image/SVG modal -->
    <div id="overlay" class="overlay" role="dialog" aria-modal="true">
        <div class="modal">
            <button id="closeModal" class="close">✕</button>
            <img id="modalImg" alt="" loading="lazy" decoding="async">
            <div class="modal-controls">
                <div class="toggle"><label><input type="checkbox" id="modalSvgToggle"> SVG view</label></div>
                <div class="spacer"></div>
                <!-- NEW: image download button (soft gated) -->
                <a id="dlImg" class="btn" style="display:inline-block;padding:6px 10px;border:1px solid var(--border);border-radius:8px;background:var(--card);color:var(--fg)" download>Download image</a>
                <button id="dlVideo" class="btn" title="Download current carousel as MP4">Download MP4</button>
                <div class="nav">
                    <button id="modalPrev" title="Previous in sequence">← Prev</button>
                    <button id="modalNext" title="Next in sequence">Next →</button>
                </div>
            </div>
            <div id="modalCarousel" class="modal-carousel"></div>
            <div id="modalMeta" style="margin-top:8px;color:#c9d3e5;font-size:13px"></div>
        </div>
    </div>

    <!-- Upgrade / Donate modal -->
    <div id="proModal" class="overlay-lite">
        <div class="modal-lite">
            <h3>Upgrade to Orb Atlas Pro</h3>
            <div>Unlock advanced sorts, more downloads, and future extended datasets.</div>
            <div class="row">
                <a id="goUpgrade" class="btn primary" target="_blank" rel="noopener">Upgrade $1.99 (PayPal)</a>
                <a id="goDonate" class="btn" target="_blank" rel="noopener">Donate (Venmo)</a>
                <button id="iPaid" class="btn">I already upgraded</button>
                <button id="closePro" class="btn">Later</button>
            </div>
            <div style="margin-top:10px" class="muted">
                Client-side unlock for quick testing. You can harden later with server checks.
            </div>
        </div>
    </div>

    <script>
        /* ===== Monetization config ===== */
        const UPGRADE_URL = "https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=K338CMZAT6YD6"; // $1.99
        const DONATE_URL = "https://venmo.com/code?user_id=3930194146494448567&created=1756688818.684348&printed=1"; // any amount

        /* ===== Pro state & gating helpers (client-only) ===== */
        function isPro() { try { return localStorage.getItem("atlas_pro") === "1"; } catch { return false; } }
        function setPro(v) { try { localStorage.setItem("atlas_pro", v ? "1" : "0"); } catch { } }
        function showProModal() { document.getElementById("proModal").style.display = "block"; }
        function hideProModal() { document.getElementById("proModal").style.display = "none"; }

        // Separate soft limits: 3 SVGs and 3 images per browser
        function getDL(kind) { try { return +(localStorage.getItem("atlas_dl_" + kind) || "0"); } catch { return 0; } }
        function setDL(kind, n) { try { localStorage.setItem("atlas_dl_" + kind, String(n)); } catch { } }
        function allowDownload(kind) {
            if (isPro()) return true;
            let n = getDL(kind);
            if (n >= 3) {
                showProModal();
                toast(`You've used your 3 free ${kind.toUpperCase()} downloads. Please upgrade to continue.`);
                return false;
            }
            setDL(kind, n + 1);
            return true;
        }

        // Wire header + modal
        (function wireMonetizationUI() {
            const up = document.getElementById("upgradeBtn");
            const dn = document.getElementById("donateBtn");
            const pm = document.getElementById("proModal");
            const goU = document.getElementById("goUpgrade");
            const goD = document.getElementById("goDonate");
            const iP = document.getElementById("iPaid");
            const cP = document.getElementById("closePro");

            if (up) up.addEventListener("click", showProModal);
            if (dn) dn.addEventListener("click", () => window.open(DONATE_URL, "_blank"));
            if (pm) {
                goU.href = UPGRADE_URL;
                goD.href = DONATE_URL;
                iP.addEventListener("click", () => { setPro(true); hideProModal(); toast("Pro unlocked on this browser."); refresh(); });
                cP.addEventListener("click", hideProModal);
                pm.addEventListener("click", (e) => { if (e.target.id === "proModal") hideProModal(); });
            }
            // Optional: auto-unlock via ?pro=1
            try {
                const params = new URLSearchParams(location.search);
                if (params.get("pro") === "1") { setPro(true); history.replaceState({}, "", location.pathname); }
            } catch { }
        })();

        /* --- Optional: embed SVGs in modal by fetching text and creating a data URL --- */
        const EMBED_SVG_IN_MODAL = true;

        async function fetchSvgAsDataURL(url) {
            const r = await fetch(url, { cache: "force-cache" });
            if (!r.ok) throw new Error(`SVG fetch failed: ${r.status}`);
            const txt = await r.text();
            // Data URL keeps it same‑origin and avoids tainting the canvas later
            return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(txt);
        }

        async function resolveSvgURL(tries) {
            for (const url of tries) {
                try {
                    // quick existence check with HEAD (fast & cacheable)
                    const h = await fetch(url, { method: "HEAD" });
                    if (h.ok) return url;
                } catch { }
            }
            throw new Error("No matching SVG file found.");
        }

        async function setModalSvg(imgEl, tries) {
            try {
                const url = await resolveSvgURL(tries);
                imgEl.onerror = null;
                imgEl.loading = "lazy"; imgEl.decoding = "async";
                imgEl.src = EMBED_SVG_IN_MODAL ? (await fetchSvgAsDataURL(url)) : url;
            } catch (e) {
                toast("No matching SVG file found for this item.");
                imgEl.removeAttribute("src");
            }
        }

        /* ===== Existing viewer code (merged) ===== */
        /* --- Perf helpers: toast + debounce + SVG cache --- */
        function toast(msg, ms=3000){
            const s = document.getElementById("status"); if (!s) return;
            s.textContent = msg;
            clearTimeout(toast._t); toast._t = setTimeout(()=>{ s.textContent = ""; }, ms);
        }
        function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t = setTimeout(()=>fn.apply(null,a), ms); }; }
        const svgCache = {}; // key -> resolved successful URL
        const SEQ_CACHE = new Map();

        const CODEBOOK_URL = "sequences_merge/symbol_codebook.json";
        let CODEBOOK_CLUSTERS = [];
        const CODEBOOK_PROMISE = loadCodebookData().then(clusters => {
            CODEBOOK_CLUSTERS = clusters;
            return clusters;
        });

        const THUMB_TO_INDEX = new Map();
        let resolveDataReady;
        const dataReady = new Promise(resolve => { resolveDataReady = resolve; });

        const sequenceClusterPromises = new Map();
        const CLUSTER_MEMBERS = new Map();
        const CLUSTER_WINDOW_FEATURES = "width=980,height=720,resizable=yes,scrollbars=yes";

        function sequenceJsonURL(jsonFile) {
            if (!jsonFile) return null;
            const safe = String(jsonFile).split('/').map(part => encodeURIComponent(part)).join('/');
            return `sequences_merge/${safe}.sequence.json`;
        }

        async function loadSequenceMetadata(jsonFile) {
            if (!jsonFile) return null;
            if (SEQ_CACHE.has(jsonFile)) return SEQ_CACHE.get(jsonFile);
            const prom = (async () => {
                try {
                    const url = sequenceJsonURL(jsonFile);
                    if (!url) return null;
                    const res = await fetch(url, { cache: "force-cache" });
                    if (!res.ok) throw new Error(`HTTP ${res.status}`);
                    return await res.json();
                } catch (err) {
                    console.warn('sequence fetch failed', err);
                    return null;
                }
            })();
            SEQ_CACHE.set(jsonFile, prom);
            return prom;
        }

        async function loadCodebookData() {
            try {
                const res = await fetch(CODEBOOK_URL, { cache: "force-cache" });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const text = await res.text();
                const safe = text.replace(/\bNaN\b/g, "null");
                const data = JSON.parse(safe);
                const clusters = Array.isArray(data?.clusters) ? data.clusters : [];
                return clusters.map(cluster => ({
                    cluster_id: Number(cluster.cluster_id),
                    token: cluster.token || "",
                    count: Number(cluster.count) || 0,
                    thumb_obj: normalizeThumbName(cluster?.prototype?.thumb_obj || "")
                }));
            } catch (err) {
                console.warn('codebook fetch failed', err);
                return [];
            }
        }

        function rebuildThumbIndex() {
            THUMB_TO_INDEX.clear();
            DATA.forEach((it, idx) => {
                const key = normalizeThumbName(it.thumb_obj);
                if (key && !THUMB_TO_INDEX.has(key)) {
                    THUMB_TO_INDEX.set(key, idx);
                }
            });
        }

        function ensureSequenceClusters(jsonFile) {
            if (!jsonFile) return Promise.resolve();
            if (sequenceClusterPromises.has(jsonFile)) return sequenceClusterPromises.get(jsonFile);
            const prom = loadSequenceMetadata(jsonFile).then(seq => {
                if (!seq || !Array.isArray(seq.events)) return;
                seq.events.forEach(ev => {
                    const cid = Number(ev.cluster_id);
                    const thumb = normalizeThumbName(ev.thumb_obj);
                    if (!Number.isFinite(cid) || !thumb) return;
                    let arr = CLUSTER_MEMBERS.get(cid);
                    if (!arr) {
                        arr = [];
                        CLUSTER_MEMBERS.set(cid, arr);
                    }
                    if (!arr.some(item => item.thumb_obj === thumb)) {
                        arr.push({
                            thumb_obj: thumb,
                            json_file: jsonFile,
                            event_index: ev.event_index
                        });
                    }
                });
            }).catch(err => {
                console.warn('cluster mapping failed', err);
            });
            sequenceClusterPromises.set(jsonFile, prom);
            return prom;
        }

        function clusterMemberKey(entry) {
            if (!entry) return "";
            const thumb = normalizeThumbName(entry.thumb_obj || entry.thumb_scene || "");
            const json = (entry.json_file || "").toLowerCase();
            const idx = entry.event_index === undefined || entry.event_index === null ? "" : String(entry.event_index);
            return `${thumb}|${json}|${idx}`;
        }

        function enrichClusterMemberEntry(entry) {
            if (!entry) return null;
            const normalized = normalizeThumbName(entry.thumb_obj || entry.thumb_scene || "");
            const idx = normalized ? THUMB_TO_INDEX.get(normalized) : undefined;
            const hasIdx = typeof idx === "number";
            const row = hasIdx ? DATA[idx] : null;
            const scenePath = row ? sanitizeRelativePath(row.thumb) : "";
            const objPathSource = row ? row.thumb_obj : (entry.thumb_obj || entry.thumb_scene || "");
            const objectPath = sanitizeRelativePath(objPathSource) || normalized;
            return {
                thumb_obj: objectPath,
                thumb_scene: scenePath,
                json_file: entry.json_file || (row ? row.json_file : ""),
                event_index: entry.event_index ?? (row ? row.event_index : ""),
                dataIdx: hasIdx ? idx : null
            };
        }

        async function streamClusterMembers(clusterId, onBatch) {
            await dataReady;
            const files = Array.from(new Set(DATA.map(it => it.json_file).filter(Boolean)));
            const seen = new Set();

            const emitFresh = (done = false) => {
                const base = CLUSTER_MEMBERS.get(clusterId) || [];
                const fresh = [];
                for (const item of base) {
                    const key = clusterMemberKey(item);
                    if (!key || seen.has(key)) continue;
                    seen.add(key);
                    const enriched = enrichClusterMemberEntry(item);
                    if (enriched) fresh.push(enriched);
                }
                if (!fresh.length && !done) return;
                if (typeof onBatch === "function") {
                    onBatch({ items: fresh, done });
                }
            };

            emitFresh(false);

            const tasks = files.map(file =>
                ensureSequenceClusters(file)
                    .then(() => emitFresh(false))
                    .catch(() => emitFresh(false))
            );

            if (tasks.length) {
                await Promise.allSettled(tasks);
            }

            emitFresh(true);
        }

        async function waitForClusterWindowReady(win, timeoutMs = 5000) {
            const start = Date.now();
            while (Date.now() - start < timeoutMs) {
                if (!win || win.closed) return false;
                if (typeof win.renderClusterInit === "function" && typeof win.renderClusterBatch === "function") {
                    return true;
                }
                await new Promise(resolve => setTimeout(resolve, 30));
            }
            return typeof win?.renderClusterInit === "function" && typeof win?.renderClusterBatch === "function";
        }

        async function openClusterWindow(cluster, preOpenedWindow) {
            const name = `codebook_cluster_${cluster?.cluster_id ?? ""}`;
            const win = preOpenedWindow || window.open("", name, CLUSTER_WINDOW_FEATURES);
            if (!win) {
                toast("Please allow pop-ups for cluster viewer.");
                return;
            }
            try {
                if (!preOpenedWindow) {
                    win.document.write("<!doctype html><title>Loading…</title><body style='background:#0b0d12;color:#c9d3e5;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;padding:24px;'>Loading cluster…</body>");
                    win.document.close();
                }
                const clusterTitle = cluster.token ? `Cluster ${cluster.cluster_id} • ${cluster.token}` : `Cluster ${cluster.cluster_id}`;
                const baseHref = (() => {
                    try { return new URL('.', document.baseURI).href; }
                    catch (err) {
                        try { return new URL('.', location.href).href; }
                        catch { return '/'; }
                    }
                })();
                const safeBaseHref = String(baseHref || '/').replace(/"/g, '&quot;');
                if (win.closed) return;
                    const html = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>${clusterTitle}</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<base href="${safeBaseHref}">
<style>
:root { color-scheme: dark; font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; background:#0b0d12; color:#e7eaf0; }
body { margin:0; background:#0b0d12; color:#e7eaf0; }
header { padding:16px 20px; border-bottom:1px solid #243041; display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
header h1 { font-size:16px; margin:0; }
header span { font-size:12px; color:#9aa3b2; }
header button { margin-left:auto; padding:6px 10px; border-radius:999px; border:1px solid #243041; background:#131722; color:#e7eaf0; cursor:pointer; }
header button:hover { border-color:#395072; }
main { padding:18px; }
.grid { display:grid; gap:14px; grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); }
.cluster-card { background:#131722; border:1px solid #243041; border-radius:12px; overflow:hidden; display:flex; flex-direction:column; }
.cluster-card button { padding:0; border:0; background:none; color:inherit; text-align:left; cursor:pointer; display:flex; flex-direction:column; height:100%; }
.cluster-card button:focus-visible { outline:2px solid #58a6ff; outline-offset:2px; }
.cluster-card img { width:100%; aspect-ratio:1/1; object-fit:cover; background:#000; }
.cluster-card .meta { padding:10px 12px; font-size:12px; line-height:1.4; color:#c9d3e5; display:flex; flex-direction:column; gap:4px; }
.cluster-card .status { font-size:11px; color:#9aa3b2; }
.cluster-card .chip { display:inline-block; padding:2px 6px; border-radius:999px; background:#1c2330; color:#9aa3b2; font-size:10px; letter-spacing:.04em; text-transform:uppercase; }
.status-line { margin-top:16px; font-size:12px; color:#9aa3b2; }
.hidden { display:none !important; }
</style>
</head>
<body>
<header>
  <h1 id="clusterTitle">${clusterTitle}</h1>
  <span id="clusterMeta"></span>
  <button id="focusMain" type="button">Focus main viewer</button>
</header>
<main>
  <div id="clusterStatus" class="status-line">Loading members…</div>
  <div id="clusterGrid" class="grid hidden" aria-live="polite"></div>
</main>
<script>
const state = { map: new Map(), expected: 0, done: false };
const gridEl = document.getElementById('clusterGrid');
const statusEl = document.getElementById('clusterStatus');
const metaEl = document.getElementById('clusterMeta');
function encodePath(name){ return name ? name.split('/').map(encodeURIComponent).join('/') : ''; }
function focusMain(){ if (window.opener && !window.opener.closed){ window.opener.focus(); } }
function handleClick(name){
  if (!name) return;
  if (window.opener && !window.opener.closed && typeof window.opener.handleCodebookSelection === 'function'){
    window.opener.focus();
    window.opener.handleCodebookSelection(name);
  } else {
    alert('Main viewer not available.');
  }
}
function normalizeName(name){
  if (!name) return '';
  const normalized = String(name).replace(/\\/g, '/');
  const parts = normalized.split('/').filter(Boolean);
  return parts.length ? parts[parts.length - 1].toLowerCase() : normalized.toLowerCase();
}
  function itemKey(item){
    const thumb = normalizeName(item.thumb_scene || item.thumb_obj);
    const json = (item.json_file || '').toLowerCase();
    const idx = item.event_index === undefined || item.event_index === null ? '' : String(item.event_index);
    return thumb + '|' + json + '|' + idx;
}
function sortItems(a, b){
  const aj = (a.json_file || '').toLowerCase();
  const bj = (b.json_file || '').toLowerCase();
  if (aj && bj && aj !== bj) return aj < bj ? -1 : 1;
  if (aj && !bj) return -1;
  if (bj && !aj) return 1;
  const ai = Number(a.event_index);
  const bi = Number(b.event_index);
  const aFinite = Number.isFinite(ai);
  const bFinite = Number.isFinite(bi);
  if (aFinite && bFinite && ai !== bi) return ai - bi;
  if (aFinite && !bFinite) return -1;
  if (!aFinite && bFinite) return 1;
  const at = (a.thumb_obj || a.thumb_scene || '').toLowerCase();
  const bt = (b.thumb_obj || b.thumb_scene || '').toLowerCase();
  if (at !== bt) return at < bt ? -1 : 1;
  return 0;
}
function renderGrid(){
  if (!gridEl) return;
  const items = Array.from(state.map.values()).sort(sortItems);
  const frag = document.createDocumentFragment();
  items.forEach(item => {
    const card = document.createElement('article');
    card.className = 'cluster-card';
    const button = document.createElement('button');
    button.type = 'button';
    button.addEventListener('click', () => handleClick(item.thumb_obj));
    const img = document.createElement('img');
    img.loading = 'lazy';
    img.decoding = 'async';
    let src = '';
    if (item.thumb_scene){
      src = 'thumbs/' + encodePath(item.thumb_scene);
      img.dataset.previewKind = 'scene';
    } else if (item.thumb_obj){
      src = 'thumbs_obj/' + encodePath(item.thumb_obj);
      img.dataset.previewKind = 'object';
    }
    if (src){
      img.src = src;
      img.alt = item.thumb_scene || item.thumb_obj || 'Cluster thumbnail';
    } else {
      img.alt = 'Missing thumbnail';
    }
    button.appendChild(img);
    const meta = document.createElement('div');
    meta.className = 'meta';
    if (item.json_file){
      const title = document.createElement('div');
      title.innerHTML = '<strong>' + item.json_file + '</strong>';
      meta.appendChild(title);
    }
    if (item.event_index !== undefined && item.event_index !== null && item.event_index !== ''){
      const info = document.createElement('div');
      info.textContent = 'Event #' + item.event_index;
      meta.appendChild(info);
    }
    if (item.dataIdx === null){
      const warn = document.createElement('div');
      warn.className = 'status';
      warn.textContent = 'Not present in atlas dataset';
      meta.appendChild(warn);
    }
    if (item.isPrototype){
      const chip = document.createElement('div');
      chip.className = 'chip';
      chip.textContent = 'Codebook prototype';
      meta.appendChild(chip);
    }
    button.appendChild(meta);
    card.appendChild(button);
    frag.appendChild(card);
  });
  gridEl.replaceChildren(frag);
  gridEl.classList.toggle('hidden', !items.length);
}
function updateStatus(){
  if (!statusEl) return;
  const loaded = state.map.size;
  let text = '';
  if (!state.done){
    if (!loaded) text = 'Loading members…';
      else if (state.expected){
        const capped = Math.min(loaded, state.expected);
        text = 'Loading members… (' + capped + ' of ' + state.expected + ')';
      } else {
        text = 'Loading members… (' + loaded + ')';
      }
    } else {
      if (!loaded) text = 'No thumb.obj members were found for this cluster.';
      else if (state.expected && loaded < state.expected) text = 'Loaded ' + loaded + ' of ' + state.expected + ' members.';
      else text = '';
  }
  statusEl.textContent = text;
  statusEl.classList.toggle('hidden', !text);
}
function mergeItems(items){
  let changed = false;
  items.forEach(item => {
    if (!item) return;
    const key = itemKey(item);
    if (!key) return;
    const existing = state.map.get(key);
    if (existing){
      const merged = Object.assign({}, existing, item);
      merged.isPrototype = Boolean(existing.isPrototype || item.isPrototype);
      state.map.set(key, merged);
    } else {
      state.map.set(key, Object.assign({}, item));
    }
    changed = true;
  });
  if (changed){
    renderGrid();
  }
}
window.renderClusterInit = function(payload){
  const cluster = payload && payload.cluster;
  if (cluster){
    const titleEl = document.getElementById('clusterTitle');
      if (titleEl){
        titleEl.textContent = cluster.title || ('Cluster ' + cluster.id);
      }
      if (metaEl){
        metaEl.textContent = cluster.count ? (cluster.count + ' total members') : '';
      }
    if (typeof cluster.count === 'number'){
      state.expected = cluster.count;
    }
  }
  if (Array.isArray(payload?.items) && payload.items.length){
    mergeItems(payload.items);
  }
  updateStatus();
};
window.renderClusterBatch = function(items, meta){
  if (meta && typeof meta.expectedCount === 'number'){
    state.expected = meta.expectedCount;
  }
  if (Array.isArray(items) && items.length){
    mergeItems(items);
  }
  if (meta && meta.done){
    state.done = true;
  }
  updateStatus();
};
window.renderClusterDone = function(meta){
  if (meta && typeof meta.expectedCount === 'number'){
    state.expected = meta.expectedCount;
  }
  state.done = true;
  updateStatus();
};
document.getElementById('focusMain').addEventListener('click', focusMain);
updateStatus();
<\/script>
</body>
</html>`;
                win.document.open();
                win.document.write(html);
                win.document.close();

                const ready = await waitForClusterWindowReady(win);
                if (!ready || win.closed) return;

                const headerPayload = {
                    cluster: {
                        id: cluster.cluster_id,
                        title: clusterTitle,
                        token: cluster.token || "",
                        count: cluster.count || 0
                    },
                    items: []
                };
                if (typeof win.renderClusterInit === "function") {
                    win.renderClusterInit(headerPayload);
                }

                await streamClusterMembers(cluster.cluster_id, ({ items, done }) => {
                    if (!win || win.closed) return;
                    if (typeof win.renderClusterBatch === "function") {
                        win.renderClusterBatch(items, { expectedCount: cluster.count || 0, done });
                    }
                });

                if (!win.closed && typeof win.renderClusterDone === "function") {
                    win.renderClusterDone({ expectedCount: cluster.count || 0 });
                }
            } catch (err) {
                console.error(err);
                if (!win || win.closed) return;
                win.document.open();
                win.document.write(`<!doctype html><title>Error</title><body style="background:#0b0d12;color:#e7eaf0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;padding:24px;">Failed to load cluster members.<br><br><code>${String(err)}</code></body>`);
                win.document.close();
            }
        }

        function renderCodebookSidebar(clusters) {
            const sidebar = document.getElementById("codebookSidebar");
            if (!sidebar) return;
            const body = sidebar.querySelector(".sidebar-body");
            if (!body) return;
            if (!Array.isArray(clusters) || !clusters.length) {
                body.innerHTML = '<div class="sidebar-empty">Codebook unavailable.</div>';
                return;
            }
            const frag = document.createDocumentFragment();
            clusters.forEach(cluster => {
                const btn = document.createElement("button");
                btn.type = "button";
                btn.className = "codebook-entry";
                btn.dataset.cluster = String(cluster.cluster_id ?? "");
                const clusterThumb = normalizeThumbName(cluster.thumb_obj);
                if (clusterThumb) {
                    btn.dataset.thumbObj = clusterThumb;
                }

                const previewWrap = document.createElement("span");
                previewWrap.className = "preview";
                if (clusterThumb) {
                    const info = bestPreviewForThumbObj(clusterThumb);
                    if (info.src) {
                        const img = document.createElement("img");
                        img.loading = "lazy";
                        img.decoding = "async";
                        img.alt = `Cluster ${cluster.cluster_id ?? "?"} preview`;
                        img.dataset.role = "cluster-preview";
                        img.dataset.clusterPreviewSrc = info.src;
                        img.dataset.previewKind = info.kind;
                        img.src = info.src;
                        previewWrap.appendChild(img);
                    } else {
                        const missing = document.createElement("span");
                        missing.className = "missing-thumb";
                        missing.textContent = "No thumb";
                        previewWrap.appendChild(missing);
                    }
                } else {
                    const missing = document.createElement("span");
                    missing.className = "missing-thumb";
                    missing.textContent = "No thumb";
                    previewWrap.appendChild(missing);
                }

                const infoWrap = document.createElement("span");
                infoWrap.className = "info";
                const strong = document.createElement("strong");
                strong.textContent = `${cluster.token ? `${cluster.token} • ` : ""}Cluster ${cluster.cluster_id ?? "?"}`;
                const small = document.createElement("small");
                small.textContent = cluster.count ? `${cluster.count} items` : "Open cluster";
                infoWrap.appendChild(strong);
                infoWrap.appendChild(small);

                btn.appendChild(previewWrap);
                btn.appendChild(infoWrap);

                btn.addEventListener("click", () => {
                    const w = window.open("", `codebook_cluster_${cluster.cluster_id}`, CLUSTER_WINDOW_FEATURES);
                    if (!w) { toast("Please allow pop-ups for cluster viewer."); return; }
                    w.document.write("<!doctype html><title>Loading…</title><body style='background:#0b0d12;color:#c9d3e5;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;padding:24px;'>Loading cluster…</body>");
                    w.document.close();
                    btn.classList.add("busy");
                    openClusterWindow(cluster, w).finally(() => btn.classList.remove("busy"));
                });
                frag.appendChild(btn);
            });
            body.innerHTML = "";
            body.appendChild(frag);
            refreshCodebookSidebarPreviews();
        }

        function wireCodebookChrome() {
            const sidebar = document.getElementById("codebookSidebar");
            const drop = document.getElementById("codebookDrop");
            const toggle = document.getElementById("codebookToggle");
            if (drop && sidebar) {
                drop.addEventListener("click", () => {
                    sidebar.classList.add("collapsed");
                    if (toggle) toggle.focus();
                });
            }
            if (toggle && sidebar) {
                toggle.addEventListener("click", () => {
                    sidebar.classList.remove("collapsed");
                    sidebar.focus();
                });
            }
        }

        wireCodebookChrome();
        CODEBOOK_PROMISE.then(renderCodebookSidebar).catch(() => {
            const body = document.querySelector("#codebookSidebar .sidebar-body");
            if (body) body.innerHTML = '<div class="sidebar-empty">Failed to load codebook.</div>';
        });
        
        let DATA = [], CURRENT = [], CURRENT_IDX = [];
        let sortAsc = true, groupMode = "none", sortMode = "hue", thumbMode = "object", svgStyle = "default";
        let hideDup = false;
        let currentView = "all"; // 'all' | 'similar' | 'grouped'
        const $ = sel => document.querySelector(sel);
        const gridEl = $("#grid"), note = $("#note"), countBadge = $("#countBadge"), sentinel = $("#sentinel");

        function setCountBadge(total) {
            if (!countBadge) return;
            const value = Number.isFinite(total) ? total : 0;
            countBadge.dataset.count = String(value);
            countBadge.textContent = `${value.toLocaleString()} items`;
        }

        const STYLE_ALIASES = {
            default: ["", "_outline", "_smooth", "_bezier", "_skeleton", "_rings", "_hull", "_edges", "_ellipse", "_contour", "_convex"],
            outline: ["_outline", "_contour"], smooth: ["_smooth"], bezier: ["_bezier"], skeleton: ["_skeleton"], rings: ["_rings"],
            hull: ["_hull", "_convex"], edges: ["_edges"], ellipse: ["_ellipse"]
        };

        const num = (x, d = null) => { const v = parseFloat(x); return Number.isFinite(v) ? v : d; };
        function updateHueRange() {
            const minVal = parseInt($("#hmin").value, 10), maxVal = parseInt($("#hmax").value, 10);
            const startPct = (minVal / 360) * 100, endPct = (maxVal / 360) * 100;
            $("#hmax").style.background = `linear-gradient(to right, var(--border) 0%, var(--border) ${startPct}%, var(--acc) ${startPct}%, var(--acc) ${endPct}%, var(--border) ${endPct}%, var(--border) 100%)`;
        }
        function hueOf(row) {
            const h = num(row.h_deg_img, null);
            if (h !== null) return (h % 360 + 360) % 360;
            const hex = row.hex_img || row.hex; if (!hex || hex[0] !== "#") return 999;
            const s = hex.slice(1); const n = parseInt(s.length === 3 ? s.split("").map(c => c + c).join("") : s, 16);
            if (!Number.isFinite(n)) return 999;
            const r = (n >> 16 & 255) / 255, g = (n >> 8 & 255) / 255, b = (n & 255) / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b); if (max === min) return 999;
            let hdeg = 0, d = max - min;
            if (max === r) hdeg = ((g - b) / d) * 60; else if (max === g) hdeg = (2 + (b - r) / d) * 60; else hdeg = (4 + (r - g) / d) * 60;
            if (hdeg < 0) hdeg += 360; return hdeg;
        }
        function pct(values, p) { if (!values.length) return 0; const a = [...values].sort((x, y) => x - y); const i = Math.floor(p * (a.length - 1)); return a[i]; }

        /* === Thumb helpers (place above normalizeRow) === */
        const pickFirst = (...xs) =>
            xs.find(v => typeof v === "string" && v.trim().length) || "";

        const isAbsoluteURL = (p) =>
            /^https?:\/\//i.test(p || "") || /^data:/i.test(p || "") || (p || "").startsWith("/");

        const normalizeThumbName = (name) => {
            if (!name) return "";
            const clean = String(name).replace(/\\/g, "/").trim();
            if (!clean) return "";
            const parts = clean.split("/").filter(Boolean);
            return (parts.length ? parts[parts.length - 1] : clean).trim();
        };

        const sanitizeRelativePath = (name) => {
            if (!name) return "";
            const clean = String(name).replace(/\\/g, "/").trim();
            if (!clean) return "";
            const parts = clean.split("/").filter(part => part && part !== "." && part !== "..");
            return parts.join("/");
        };

        const encodeThumbPath = (name) =>
            name ? name.split("/").map(part => encodeURIComponent(part)).join("/") : "";

        function bestPreviewForThumbObj(thumbObjName) {
            const normalized = normalizeThumbName(thumbObjName);
            if (!normalized) {
                return { src: "", kind: "none" };
            }
            const fallback = `thumbs_obj/${encodeThumbPath(normalized)}`;
            const idx = THUMB_TO_INDEX.get(normalized);
            if (typeof idx === "number" && DATA[idx]) {
                const row = DATA[idx];
                const scenePath = sanitizeRelativePath(row.thumb);
                if (scenePath) {
                    return { src: `thumbs/${encodeThumbPath(scenePath)}`, kind: "scene", fallback };
                }
                const objectPath = sanitizeRelativePath(row.thumb_obj);
                if (objectPath) {
                    return { src: `thumbs_obj/${encodeThumbPath(objectPath)}`, kind: "object", fallback };
                }
            }
            return { src: fallback, kind: "object", fallback };
        }

        function refreshCodebookSidebarPreviews() {
            const entries = document.querySelectorAll(".codebook-entry");
            entries.forEach(entry => {
                const thumbObj = entry.dataset.thumbObj;
                if (!thumbObj) return;
                const img = entry.querySelector("img[data-role='cluster-preview']");
                if (!img) return;
                const info = bestPreviewForThumbObj(thumbObj);
                if (!info.src) return;
                if (img.dataset.clusterPreviewSrc !== info.src) {
                    img.dataset.clusterPreviewSrc = info.src;
                    img.src = info.src;
                }
                img.dataset.previewKind = info.kind;
            });
        }


        /* ========== CSV NORMALIZATION (revised) ========== */
        function normalizeRow(r, i) {
            // scene/object thumbs — accept many possible CSV header names
            const thumbScene = pickFirst(
                r.thumb, r.thumb_path, r.scene_thumb, r.sceneThumb,
                r.thumb_scene, r.frame_thumb, r.thumb_file, r.thumb_url, r.scene_thumb_url
            );

            const thumbObj = pickFirst(
                r.thumb_obj, r.thumb_object, r.object_thumb, r.object_thumb_path,
                r.obj_thumb, r.thumb_obj_file, r.thumb_obj_url, r.object_thumb_url
            );

            // sanitize: normalize slashes + trim
            const clean = (s) => (typeof s === "string" ? sanitizeRelativePath(s) : "");
            const normShape = (() => {
                const raw = r.shape ?? r.shape_class;
                if (raw === undefined || raw === null) return "other";
                const txt = String(raw).trim();
                return txt.length ? txt : "other";
            })();
            const normMotion = (() => {
                const raw = r.motion ?? r.motion_class;
                if (raw === undefined || raw === null) return "unknown";
                const txt = String(raw).trim();
                return txt.length ? txt : "unknown";
            })();

            return {
                _i: i,
                h_deg_img: num(r.h_deg_img, num(r.h_deg, NaN)),
                s_norm: num(r.s_norm, num(r.s, NaN)),
                v_norm: num(r.v_norm, num(r.v, NaN)),

                hex_img: r.hex_img || r.hex || "",

                json_file: r.json_file || r.json || "",
                video_file: r.video_file || r.video || "",
                event_index: r.event_index || r.event || "",

                start_ts: num(r.start_ts, num(r.t_start, 0)),
                end_ts: num(r.end_ts, num(r.t_end, 0)),

                // NEW: broadened thumbnail field mapping
                thumb: clean(thumbScene),
                thumb_obj: clean(thumbObj),

                svg: r.svg || r.svg_path || r.svg_file || "",

                shape: normShape,
                motion: normMotion,
                sharpness: num(r.sharpness, NaN),
                area_norm: num(r.area_norm, NaN),
                circ: num(r.circ, NaN),
                aspect_ratio: num(r.aspect_ratio, NaN),
                h_range_deg: num(r.h_range_deg, NaN)
            };
        }


        function colorGroup(it) {
            const h = hueOf(it), s = num(it.s_norm, 0), v = num(it.v_norm, 0);
            if (!Number.isFinite(h) || s < 0.1) return v > 0.8 ? "White" : (v < 0.2 ? "Black" : "Gray");
            if (h < 15 || h >= 345) return "Red"; if (h < 45) return "Orange"; if (h < 75) return "Yellow";
            if (h < 150) return "Green"; if (h < 210) return "Cyan"; if (h < 270) return "Blue";
            if (h < 300) return "Purple"; if (h < 345) return "Magenta"; return "Other";
        }

        function applyFilters() {
            const q = ($("#search").value || "").toLowerCase().trim();
            const imgOnly = $("#imgOnly").checked, hiDup = $("#hideDup").checked;
            const hmin = parseInt($("#hmin").value, 10), hmax = parseInt($("#hmax").value, 10);
            $("#hbadge").textContent = `${hmin}°–${hmax}°`;

            const scb = [...document.querySelectorAll('#shapeBox input[type=checkbox]')];
            const enabledShapes = new Set(scb.filter(cb => cb.checked).map(cb => cb.dataset.shape));
            const availableShapeFilters = new Set(scb.map(cb => cb.dataset.shape));
            const chips = [...document.querySelectorAll('#colorChips .chip.sel')];
            const colorSel = new Set(chips.map(c => c.dataset.color));
            const tier = $("#motionTier").value;

            const out = []; CURRENT_IDX = [];
            for (let i = 0; i < DATA.length; i++) {
                const it = DATA[i];
                if (hiDup && it.isDuplicate) continue;
                if (imgOnly && !(it.thumb || it.thumb_obj)) continue;

                const h = hueOf(it);
                if (Number.isFinite(h)) {
                    const inRange = (hmin <= hmax) ? (h >= hmin && h <= hmax) : (h >= hmin || h <= hmax);
                    if (!inRange) continue;
                }
                const shapeKey = it.shape || "other";
                if (scb.length && availableShapeFilters.has(shapeKey) && !enabledShapes.has(shapeKey)) {
                    continue;
                }
                if (colorSel.size && !colorSel.has(colorGroup(it))) continue;
                if (tier !== "any" && it.motionTier !== tier) continue;

                if (q) {
                    const hay = `${it.json_file} ${it.video_file} ${it.hex_img}`.toLowerCase();
                    if (!hay.includes(q)) continue;
                }
                CURRENT_IDX.push(i); out.push(it);
            }
            return out;
        }

        function dedupeByVideoClusters() {
            const byVid = {}; DATA.forEach((it, i) => { const v = it.video_file || "_"; (byVid[v] || (byVid[v] = [])).push(i); });
            for (const vid in byVid) {
                const idxs = byVid[vid].sort((a, b) => num(DATA[a].start_ts, 0) - num(DATA[b].start_ts, 0));
                let i = 0;
                while (i < idxs.length) {
                    let rep = idxs[i], repSharp = num(DATA[rep].sharpness, 0), j = i + 1;
                    while (j < idxs.length) {
                        const A = idxs[i], B = idxs[j];
                        if (Math.abs(num(DATA[B].start_ts, 0) - num(DATA[A].start_ts, 0)) <= 1.0) {
                            let dh = Math.abs(hueOf(DATA[B]) - hueOf(DATA[A])); dh = Math.min(dh, 360 - dh);
                            const same = (DATA[B].shape === DATA[A].shape);
                            if (dh < 15 && same) { const sB = num(DATA[B].sharpness, 0); if (sB > repSharp) { rep = idxs[j]; repSharp = sB; } j++; continue; }
                        }
                        break;
                    }
                    for (let k = i; k < j; k++) { const x = idxs[k]; DATA[x].isDuplicate = (x !== rep); }
                    i = j;
                }
            }
        }

        function buildShapeCheckboxes() {
            const box = $("#shapeBox");
            if (!box) return;
            const prev = [...box.querySelectorAll('input[type=checkbox]')];
            const prevSelected = new Set(prev.filter(cb => cb.checked).map(cb => cb.dataset.shape));
            const hadPrevSelection = prevSelected.size > 0;
            box.innerHTML = "";
            const counts = new Map();
            DATA.forEach(it => {
                const key = (typeof it.shape === "string" && it.shape.trim().length) ? it.shape : "other";
                counts.set(key, (counts.get(key) || 0) + 1);
            });
            if (!counts.has("other")) counts.set("other", 0);
            const shapes = [...counts.entries()].sort((a, b) => b[1] - a[1]).map(([shape]) => shape);
            shapes.forEach(sh => {
                const id = "shape-" + (sh.replace(/[^a-z0-9]+/gi, "_") || "other");
                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.id = id;
                cb.dataset.shape = sh;
                cb.checked = !hadPrevSelection || prevSelected.has(sh);
                cb.addEventListener("change", refresh);
                const lbl = document.createElement("label");
                lbl.htmlFor = id;
                lbl.style.marginRight = "10px";
                lbl.appendChild(cb);
                lbl.appendChild(document.createTextNode(` ${sh} (${counts.get(sh)})`));
                box.appendChild(lbl);
            });
        }
        function buildColorChips() {
            const colors = new Set(DATA.map(colorGroup));
            const wrap = $("#colorChips"); wrap.innerHTML = "";
            colors.forEach(c => {
                const b = document.createElement("div"); b.className = "chip"; b.title = c; b.dataset.color = c;
                b.style.background = (c === "White" || c === "Gray" || c === "Black") ? c.toLowerCase() : c;
                b.addEventListener("click", () => { b.classList.toggle("sel"); refresh(); });
                wrap.appendChild(b);
            });
        }

        let stream = { i: 0, FIRST: 200, STEP: (navigator.connection && (navigator.connection.effectiveType||"").includes("2g")) ? 200 : 600, observer: null };

        function cardHTML(it, globalIdx) {
            const src = rasterUrlFor(it);
            const h = hueOf(it); const hueLbl = Number.isFinite(h) ? `${h.toFixed(1)}°` : "–";
            return `
            <div class="card" data-idx="${globalIdx}">
              <div class="swatch" style="background:${it.hex_img || '#222'}"></div>
              <div class="thumb-wrap"><img class="${it.hasWatermark ? 'thumb watermark' : 'thumb'}" src="${src}" alt="" loading="lazy" decoding="async" fetchpriority="low"></div>
              <div class="actions">
                <button class="btn-mini" data-action="svg" title="Open SVG (${svgStyle})">SVG</button>
                <button class="btn-mini" data-action="sim" title="Find similar">Similar</button>
              </div>
              <div class="meta">
                <div class="kv"><div>hue</div><code>${hueLbl}</code></div>
                <div class="kv"><div><strong>${it.json_file || "(no json)"}</strong></div><div>#${it.event_index || ""}</div></div>
                <div class="kv"><div>${it.video_file || "(video)"} • t=${(+it.start_ts).toFixed(2)}–${(+it.end_ts).toFixed(2)}s</div><div>${it.shape !== "other" ? it.shape : ""} ${it.motion && it.motion !== "unknown" ? "• " + it.motion : ""}</div></div>
                <div class="kv"><div>hex</div><code>${it.hex_img || ""}</code></div>
                <div class="kv"><div>S</div><code>${Number.isFinite(num(it.s_norm)) ? (+it.s_norm).toFixed(2) : ""}</code></div>
                <div class="kv"><div>V</div><code>${Number.isFinite(num(it.v_norm)) ? (+it.v_norm).toFixed(2) : ""}</code></div>
              </div>
            </div>`;
        }

        function wireTileClicks(rangeStart, rangeEnd) {
            const cards = gridEl.querySelectorAll(".card");
            const slice = [...cards].slice(rangeStart, rangeEnd);
            slice.forEach(card => {
                const idx = +card.dataset.idx;
                card.addEventListener("click", e => {
                    if (e.target && e.target.dataset && (e.target.dataset.action === "sim" || e.target.dataset.action === "svg")) return;
                    openModalByGlobalIndex(idx);
                });
                const btnSim = card.querySelector('[data-action="sim"]');
                const btnSvg = card.querySelector('[data-action="svg"]');
                btnSim.addEventListener("click", e => {
                    e.stopPropagation();
                    $("#status").textContent = "Finding similar...";
                    setTimeout(() => { findSimilarByGlobalIndex(idx); }, 0);
                });
                btnSvg.addEventListener("click", e => {
                    e.stopPropagation();
                    openSVGByGlobalIndex(idx);
                });
            });
        }

        function appendChunk(n) {
            const start = stream.i, end = Math.min(stream.i + n, CURRENT.length);
            if (start >= end) return;
            const frag = CURRENT.slice(start, end).map((it, localIdx) => {
                const gi = CURRENT_IDX[start + localIdx];
                return cardHTML(it, gi);
            }).join("");
            gridEl.insertAdjacentHTML("beforeend", frag);
            wireTileClicks(start, end);
            stream.i = end;
            setCountBadge(CURRENT.length);
            if (stream.i >= CURRENT.length && stream.observer) { stream.observer.disconnect(); stream.observer = null; }
        }

        function updateNote() {
            if (currentView === "similar") {
                note.textContent = `View: Similar (${CURRENT.length} items) • Sort: ${sortMode} ${sortAsc ? "↑" : "↓"}`;
            } else if (currentView === "grouped") {
                note.textContent = `View: Grouped by ${$("#groupSelect").selectedOptions[0].text} • Sort: ${sortMode} ${sortAsc ? "↑" : "↓"}`;
            } else {
                note.textContent = `View: All • Sort: ${sortMode} ${sortAsc ? "↑" : "↓"}`;
            }
        }

        function startStreaming() {
            gridEl.innerHTML = ""; stream.i = 0;
            appendChunk(stream.FIRST);
            if (stream.observer) stream.observer.disconnect();
            stream.observer = new IntersectionObserver((entries) => {
                entries.forEach(e => { if (e.isIntersecting) appendChunk(stream.STEP); });
            }, { root: null, rootMargin: "600px 0px 600px 0px", threshold: 0 });
            stream.observer.observe(sentinel);
            updateNote();
            // clear any busy line if still present
            const sEl = document.getElementById("status"); if (sEl) sEl.textContent = "";
        }

        function groupAndRender(items) {
            const keys = {}, order = [];
            function add(key, item) { if (!keys[key]) { keys[key] = []; order.push(key); } keys[key].push(item); }
            if (groupMode === "hue") {
                items.forEach(it => { const h = hueOf(it); const bin = Number.isFinite(h) ? Math.floor(h / 15) : 24; add(`Hue ${bin * 15}–${(bin + 1) * 15}°`, it); });
            } else if (groupMode === "brightness") {
                items.forEach(it => { const v = num(it.v_norm, null); add((v === null) ? "Unknown" : (v < 0.33 ? "Dark" : (v < 0.66 ? "Medium" : "Bright")), it); });
            } else if (groupMode === "saturation") {
                items.forEach(it => { const s = num(it.s_norm, null); add((s === null) ? "Unknown" : (s < 0.3 ? "Low" : (s < 0.7 ? "Medium" : "High")), it); });
            } else if (groupMode === "time") {
                items.forEach(it => { const t = Math.floor(num(it.start_ts, 0) / 10) * 10; add(`${t}–${t + 10}s`, it); });
            } else if (groupMode === "video") {
                items.forEach(it => { const vid = it.video_file || "Unknown"; const base = vid.replace(/\.[^.]+$/, ""); add(base, it); });
            }
            gridEl.innerHTML = ""; let total = 0;
            order.sort().forEach(key => {
                const h = document.createElement("div");
                h.textContent = `${key} (${keys[key].length})`;
                h.style.cssText = "grid-column:1 / -1;margin:8px 0;font-weight:700;color:#c9d3e5";
                gridEl.appendChild(h);
                keys[key].forEach(it => {
                    const gi = DATA.indexOf(it);
                    gridEl.insertAdjacentHTML("beforeend", cardHTML(it, gi));
                    total++;
                });
            });
            wireTileClicks(0, gridEl.querySelectorAll(".card").length);
            setCountBadge(total);
            currentView = "grouped"; updateNote();
            const sEl = document.getElementById("status"); if (sEl) sEl.textContent = "";
        }

        /* Robust CSV URL */
        const CSV_URL = (() => {
            const FALLBACK = 'atlas.csv';
            const pickBase = () => {
                const base = document.baseURI && document.baseURI !== 'about:blank'
                    ? document.baseURI
                    : (typeof location !== 'undefined' ? location.href : '');
                if (!base) throw new Error('no base URL');
                return base;
            };
            try {
                return new URL('atlas.csv', pickBase()).href;
            } catch (err) {
                try {
                    return new URL('atlas.csv', location.href).href;
                } catch {
                    return FALLBACK;
                }
            }
        })();

        /* ===== Modal sequence helpers (from your file) ===== */
        let MODAL = { seq: [], pos: 0, svg: false };
        function seqIndicesForVideo(videoFile) {
            const seq = []; for (let i = 0; i < DATA.length; i++) { if ((DATA[i].video_file || "") === (videoFile || "")) seq.push(i); }
            seq.sort((a, b) => {
                const A = +DATA[a].start_ts || 0, B = +DATA[b].start_ts || 0; if (A !== B) return A - B;
                const EA = parseInt(DATA[a].event_index || 0), EB = parseInt(DATA[b].event_index || 0); return (EA || 0) - (EB || 0);
            });
            return seq;
        }
        function hasThumbMedia(it) {
            return Boolean((it.thumb_obj && it.thumb_obj.trim()) || (it.thumb && it.thumb.trim()));
        }

        function rasterUrlFor(it) {
            const objSrc = (it.thumb_obj || "").trim();
            const sceneSrc = (it.thumb || "").trim();

            let chosen = "";
            let isObj = false;

            if (thumbMode === "object") {
                if (objSrc) { chosen = objSrc; isObj = true; }
                else if (sceneSrc) { chosen = sceneSrc; }
            } else {
                if (sceneSrc) { chosen = sceneSrc; }
                else if (objSrc) { chosen = objSrc; isObj = true; }
            }

            if (!chosen) return ""; // no image available

            // Absolute (http/https/data:/leading slash) — use as-is
            if (isAbsoluteURL(chosen)) return chosen;

            // Relative — keep your existing folders
            return isObj ? `thumbs_obj/${chosen}` : `thumbs/${chosen}`;
        }

        /* ===== Permissive SVG candidate list (roots + .SVG) ===== */
        function svgTriesFor(it) {
            // Active style list; "" means the plain root with no style suffix
            const styles = STYLE_ALIASES[svgStyle] || STYLE_ALIASES.default;

            // Derive base from CSV 'svg' or from thumbs if 'svg' missing
            let csvBase = null;
            if (it.svg) csvBase = it.svg.replace(/\.[^.]+$/, "");
            else if (it.thumb_obj) csvBase = it.thumb_obj.replace(/_obj\.jpg$/i, "");
            else if (it.thumb) csvBase = it.thumb.replace(/\.jpg$/i, "");

            // Build candidate "roots" to try (most specific first)
            const roots = [];
            const addRoot = (r) => { if (r && !roots.includes(r)) roots.push(r); };

            // 1) base_obj; 2) base_obj_hybrid; 3) base
            if (csvBase) {
                addRoot(csvBase + "_obj");
                addRoot(csvBase + "_obj_hybrid");
                addRoot(csvBase);
            }

            // 4) If CSV 'svg' is present and has a different base, try that too
            if (it.svg) {
                const exact = it.svg.replace(/\.[^.]+$/, "");
                if (exact && exact !== csvBase) addRoot(exact);
            }

            // Create the try list for each style and **both** .svg and .SVG
            const tries = [];
            for (const root of roots) {
                for (const suf of styles) {
                    const name = (suf === "") ? root : (root + suf);
                    tries.push(`svgs/${encodeURIComponent(name)}.svg`);
                    tries.push(`svgs/${encodeURIComponent(name)}.SVG`);
                }
            }
            return tries;
        }

        function setImgSrcWithTries(imgEl, tries) {
            const key = tries && tries.length ? tries.join("|") : "";
            if (key && svgCache[key]) { imgEl.src = svgCache[key]; return; }
            imgEl.dataset.tries = JSON.stringify(tries);
            imgEl.dataset.tryi = "0";
            imgEl.onload = () => { if (key) svgCache[key] = imgEl.src; };
            imgEl.onerror = () => {
                try {
                    const list = JSON.parse(imgEl.dataset.tries || "[]");
                    let i = parseInt(imgEl.dataset.tryi || "0", 10) + 1;
                    if (i < list.length) { imgEl.dataset.tryi = String(i); imgEl.src = list[i]; }
                    else { imgEl.onerror = null; }
                } catch (e) { imgEl.onerror = null; }
            };
            if (tries && tries.length) { imgEl.src = tries[0]; }
        }

        function renderModalSequence() {
            const cont = document.getElementById("modalCarousel"); cont.innerHTML = "";
            const seq = MODAL.seq, pos = MODAL.pos;
            for (let k = 0; k < seq.length; k++) {
                const gi = seq[k], it = DATA[gi]; const img = new Image();
                img.loading = "lazy"; img.decoding="async";
                img.className = "carousel-thumb" + (it.hasWatermark ? " wm" : ""); img.dataset.gi = String(gi);
                if (MODAL.svg) { setModalSvg(img, svgTriesFor(it)); } else { img.onerror = null; img.src = rasterUrlFor(it); }
                if (k === pos) img.classList.add("selected");
                img.addEventListener("click", (e) => { e.stopPropagation(); selectSequenceIndex(k); });
                cont.appendChild(img);
            }
            const sel = cont.querySelector(".carousel-thumb.selected"); if (sel && sel.scrollIntoView) sel.scrollIntoView({ behavior: "smooth", inline: "center", block: "nearest" });
        }
        function updateModalMain() {
            const gi = MODAL.seq[MODAL.pos], it = DATA[gi], img = document.getElementById("modalImg");
            if (MODAL.svg) { setModalSvg(img, svgTriesFor(it)); } else { img.src = rasterUrlFor(it); }
            // set download href (gated)
            const dl = document.getElementById("dlImg");
            if (dl) {
                dl.href = rasterUrlFor(it);
                dl.onclick = (e) => { if (!allowDownload("image")) { e.preventDefault(); } };
            }
            document.getElementById("modalMeta").innerHTML = `
            <div><strong>${it.json_file}</strong> (event ${it.event_index})</div>
            <div>${it.video_file} • t=${(+it.start_ts).toFixed(2)}–${(+it.end_ts).toFixed(2)}s</div>
            <div>hex ${it.hex_img || ""} • hue ${Number.isFinite(hueOf(it)) ? hueOf(it).toFixed(1) : "–"}° • S ${num(it.s_norm, 0).toFixed(2)} • V ${num(it.v_norm, 0).toFixed(2)}</div>
            <div>shape ${it.shape} • motion ${it.motion}</div>
            <div id="modalExtras" class="modal-extras">Loading sequence metadata…</div>`;
            updateModalExtras(it);
        }
        function selectSequenceIndex(k) {
            MODAL.pos = Math.max(0, Math.min(MODAL.seq.length - 1, k));
            updateModalMain();
            const cont = document.getElementById("modalCarousel");
            cont.querySelectorAll(".carousel-thumb.selected").forEach(el => el.classList.remove("selected"));
            const sel = cont.querySelector(`.carousel-thumb[data-gi="${MODAL.seq[MODAL.pos]}"]`);
            if (sel) sel.classList.add("selected");
            if (sel && sel.scrollIntoView) sel.scrollIntoView({ behavior: "smooth", inline: "center", block: "nearest" });
        }
        function stepSequence(dir) { selectSequenceIndex(MODAL.pos + (dir < 0 ? -1 : 1)); }
        function setSvgMode(on) { MODAL.svg = !!on; document.getElementById("modalSvgToggle").checked = MODAL.svg; renderModalSequence(); updateModalMain(); }
        
        function updateModalExtras(it) {
            const extrasEl = document.getElementById("modalExtras");
            if (!extrasEl) return;
            if (!it || !it.json_file) {
                extrasEl.textContent = "No sequence metadata.";
                return;
            }
            extrasEl.textContent = "Loading sequence metadata…";
            loadSequenceMetadata(it.json_file).then(seq => {
                if (!extrasEl.isConnected) return;
                if (!seq || !Array.isArray(seq.events)) {
                    extrasEl.textContent = "No sequence metadata.";
                    return;
                }
                const evIdx = Number(it.event_index);
                const ev = seq.events.find(e => Number(e.event_index) === evIdx);
                if (!ev) {
                    extrasEl.textContent = "No matching event metadata.";
                    return;
                }
                const lines = [];
                if (ev.enhanced_token) lines.push(`Token: ${ev.enhanced_token}`);
                const orientBits = [];
                if (ev.orientation) orientBits.push(String(ev.orientation));
                if (Number.isFinite(ev.orientation8)) orientBits.push(`o${ev.orientation8}`);
                if (orientBits.length) lines.push(`Orientation: ${orientBits.join(' • ')}`);
                if (Number.isFinite(ev.sector8)) lines.push(`Sector: s${ev.sector8}`);
                const vac = [];
                if (typeof ev.vacuole_count === "number") vac.push(`count ${ev.vacuole_count}`);
                if (Array.isArray(ev.vacuole_sectors8) && ev.vacuole_sectors8.length) vac.push(`sectors ${ev.vacuole_sectors8.join(',')}`);
                if (typeof ev.vacuole_mask8 === "number" && ev.vacuole_mask8 > 0) {
                    const mask = ev.vacuole_mask8.toString(2).padStart(8, '0');
                    vac.push(`mask ${mask}`);
                }
                if (vac.length) lines.push(`Vacuoles: ${vac.join(' • ')}`);
                if (typeof ev.cluster_id === "number") lines.push(`Cluster ID: ${ev.cluster_id}`);
                if (ev.flash) lines.push("Flash: ✦");
                extrasEl.innerHTML = "";
                if (!lines.length) {
                    extrasEl.textContent = "No radial/vacuole metadata.";
                    return;
                }
                lines.forEach(txt => {
                    const div = document.createElement("div");
                    div.textContent = txt;
                    extrasEl.appendChild(div);
                });
            }).catch(() => {
                if (extrasEl.isConnected) extrasEl.textContent = "Sequence metadata unavailable.";
            });
        }

        function openModalByGlobalIndex(gi) {
            const it = DATA[gi];
            const seq = seqIndicesForVideo(it.video_file);
            const pos = Math.max(0, seq.indexOf(gi));
            MODAL = { seq, pos, svg: false };
            $("#overlay").style.display = "block";
            renderModalSequence(); updateModalMain();
            const prev = document.getElementById("modalPrev");
            const next = document.getElementById("modalNext");
            const tog = document.getElementById("modalSvgToggle");
            prev.onclick = (e) => { e.stopPropagation(); stepSequence(-1); };
            next.onclick = (e) => { e.stopPropagation(); stepSequence(1); };
            tog.onchange = (e) => { e.stopPropagation(); setSvgMode(tog.checked); };
            const dlv = document.getElementById("dlVideo");
            if (dlv) dlv.onclick = (e) => {
                e.stopPropagation();
                onDownloadVideoClick().catch(err => { console.error(err); toast("MP4 download failed."); });
            };
            document.onkeydown = (ev) => {
                if ($("#overlay").style.display !== "block") return;
                if (ev.key === "ArrowLeft") { ev.preventDefault(); stepSequence(-1); }
                else if (ev.key === "ArrowRight") { ev.preventDefault(); stepSequence(1); }
                else if (ev.key.toLowerCase() === "v") { ev.preventDefault(); setSvgMode(!MODAL.svg); }
            };
        }

        window.handleCodebookSelection = function(thumbName) {
            const key = normalizeThumbName(thumbName);
            if (!key) {
                toast("No thumbnail specified for this cluster item.");
                return;
            }
            const idx = THUMB_TO_INDEX.get(key);
            if (typeof idx !== "number") {
                toast("Cluster item is not present in the current atlas view.");
                return;
            }
            openModalByGlobalIndex(idx);
        };

        function openSVGByGlobalIndex(gi) {
            if (!allowDownload("svg")) return; // soft gate
            const it = DATA[gi];
            const styles = STYLE_ALIASES[svgStyle] || STYLE_ALIASES.default;
            let base = null;
            if (it.svg) base = it.svg.replace(/\.[^.]+$/, "");
            else if (it.thumb_obj) base = it.thumb_obj.replace(/_obj\.jpg$/i, "");
            else if (it.thumb) base = it.thumb.replace(/\.jpg$/i, "");
            if (!base) { toast("No SVG name to derive from."); return; }
            const tries = [];
            for (const suf of styles) {
                if (suf === "") { if (it.svg) tries.push(`svgs/${encodeURIComponent(it.svg)}`); }
                else tries.push(`svgs/${encodeURIComponent(base + suf)}.svg`);
            }
            if (it.svg) tries.push(`svgs/${encodeURIComponent(it.svg)}`);
            (async () => {
                for (const url of tries) {
                    try { const r = await fetch(url, { method: "HEAD" }); if (r.ok) { window.open(url, "_blank"); return; } } catch { }
                }
                toast("No matching SVG file found for this item.");
            })();
        }

        // Pro-visible sort gating and key
        function isProSort(v) { return v === "hueRange_pro" || v === "sharpArea_pro"; }
        function orderKeyFor(it) {
            switch (sortMode) {
                case "hue": return hueOf(it);
                case "saturation": return num(it.s_norm, -999);
                case "brightness": return num(it.v_norm, -999);
                case "sharpness": return num(it.sharpness, -999);
                case "area": return num(it.area_norm, -999);
                case "hueRange": return num(it.h_range_deg, -999);
                case "hueRange_pro": return isPro() ? num(it.h_range_deg, -999) : -999;
                case "sharpArea_pro": return isPro() ? (num(it.sharpness, 0) * num(it.area_norm, 0)) : -999;
                default: return it._i;
            }
        }

        function refresh() {
            const sz = parseInt($("#sizeRange")?.value || "240", 10);
            document.documentElement.style.setProperty("--thumb", (isFinite(sz) ? sz : 240) + "px");
            thumbMode = $("#thumbMode").value; svgStyle = $("#svgStyle").value; groupMode = $("#groupSelect").value; sortMode = $("#sortSelect").value;
            document.body.classList.toggle('hideTTActive', $("#hideTT").checked);
            const list = applyFilters();
            // sort
            const sortedIdx = [...list.keys()].sort((a, b) => {
                const A = orderKeyFor(list[a]), B = orderKeyFor(list[b]);
                return ((Number.isFinite(A) ? A : -999) - (Number.isFinite(B) ? B : -999)) * (sortAsc ? 1 : -1);
            });
            CURRENT = sortedIdx.map(i => list[i]);
            CURRENT_IDX = sortedIdx.map(i => CURRENT_IDX[i]);
            if (groupMode === "none") { currentView = "all"; startStreaming(); } else { groupAndRender(CURRENT); }
        }

        /* ====== R2 presign + FFmpeg-wasm fallback for MP4 downloads ====== */

        // Try to download the full source video from R2 via Netlify function.
        // Expects serverless function to accept ?file=<video_file>&(optional other params) and return {url: "..."} or plain URL.
        async function downloadFullVideoFromR2(videoFile) {
            if (!videoFile) throw new Error("no video_file in record");
            const q = `/.netlify/functions/get-r2-url?file=${encodeURIComponent(videoFile)}`;
            const r = await fetch(q, { method: "GET" });
            if (!r.ok) throw new Error(`presign failed: ${r.status}`);
            // Accept JSON {url} or raw URL text
            let url;
            const ct = r.headers.get("content-type") || "";
            if (ct.includes("json")) {
                const j = await r.json(); url = j.url || j.signedUrl || j.presigned || "";
            } else {
                url = (await r.text()).trim();
            }
            if (!url) throw new Error("no URL from presign");
            const a = document.createElement("a");
            a.href = url; a.target = "_blank"; a.rel = "noopener";
            document.body.appendChild(a); a.click(); a.remove();
            return true;
        }

        // Lazy loader for FFmpeg UMD build (no <script> tag needed in HTML)
        let _ffmpeg = null;
        async function loadFFmpeg() {
            if (_ffmpeg) return _ffmpeg;
            // Load UMD wrapper
            await new Promise((res, rej) => {
                const s = document.createElement("script");
                s.src = "https://unpkg.com/@ffmpeg/ffmpeg@0.11.8/dist/umd/ffmpeg.js";
                s.onload = res; s.onerror = rej; document.head.appendChild(s);
            });
            const { createFFmpeg } = window.FFmpeg;
            const ff = createFFmpeg({
                log: false,
                corePath: "https://unpkg.com/@ffmpeg/core@0.11.8/dist/umd/ffmpeg-core.js"
            });
            await ff.load();
            _ffmpeg = ff;
            return ff;
        }

        function dataURLtoU8(dataURL) {
            const b64 = dataURL.split(',')[1]; const bin = atob(b64);
            const u8 = new Uint8Array(bin.length); for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
            return u8;
        }

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        function supportsCanvasRecording() {
            return typeof MediaRecorder !== "undefined" &&
                typeof HTMLCanvasElement !== "undefined" &&
                typeof HTMLCanvasElement.prototype?.captureStream === "function";
        }

        async function frameSourceForSequenceItem(it) {
            if (!it) return "";
            if (MODAL.svg) {
                const url = await resolveSvgURL(svgTriesFor(it));
                return EMBED_SVG_IN_MODAL ? (await fetchSvgAsDataURL(url)) : url;
            }
            return rasterUrlFor(it);
        }

        async function loadSequenceFrameImage(it) {
            const src = await frameSourceForSequenceItem(it);
            if (!src) throw new Error("No frame source available");
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.decoding = "async";
            img.loading = "eager";
            img.src = src;
            await new Promise((resolve, reject) => {
                img.onload = () => resolve(img);
                img.onerror = () => reject(new Error("Frame load failed"));
            });
            return img;
        }

        function pickCanvasMimeType() {
            if (typeof MediaRecorder === "undefined" || typeof MediaRecorder.isTypeSupported !== "function") return "";
            const candidates = [
                "video/webm;codecs=vp9",
                "video/webm;codecs=vp8",
                "video/webm;codecs=vp9,opus",
                "video/webm"
            ];
            return candidates.find(type => {
                try { return MediaRecorder.isTypeSupported(type); }
                catch { return false; }
            }) || "";
        }

        async function encodeWebMFromSequence(seq, fps = 12) {
            if (!supportsCanvasRecording()) throw new Error("MediaRecorder not supported");
            if (!Array.isArray(seq) || !seq.length) throw new Error("empty sequence");
            const firstImg = await loadSequenceFrameImage(DATA[seq[0]]);
            const width = firstImg.naturalWidth || firstImg.width || 640;
            const height = firstImg.naturalHeight || firstImg.height || 480;
            const canvas = document.createElement("canvas");
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext("2d");
            const mimeType = pickCanvasMimeType();
            const stream = canvas.captureStream(fps);
            const recorder = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);
            const chunks = [];
            recorder.ondataavailable = (evt) => { if (evt.data && evt.data.size) chunks.push(evt.data); };
            const stopPromise = new Promise((resolve, reject) => {
                recorder.onstop = () => resolve();
                recorder.onerror = (evt) => reject(evt?.error || evt || new Error("Recording failed"));
            });
            const drawImage = (img) => {
                ctx.clearRect(0, 0, width, height);
                const naturalW = img.naturalWidth || img.width || width;
                const naturalH = img.naturalHeight || img.height || height;
                const ratio = Math.min(width / naturalW, height / naturalH) || 1;
                const dw = Math.round(naturalW * ratio);
                const dh = Math.round(naturalH * ratio);
                const dx = Math.floor((width - dw) / 2);
                const dy = Math.floor((height - dh) / 2);
                ctx.drawImage(img, dx, dy, dw, dh);
            };
            recorder.start();
            drawImage(firstImg);
            await sleep(1000 / fps);
            for (let i = 1; i < seq.length; i++) {
                const img = await loadSequenceFrameImage(DATA[seq[i]]);
                drawImage(img);
                await sleep(1000 / fps);
            }
            recorder.stop();
            await stopPromise;
            stream.getTracks().forEach(track => { try { track.stop(); } catch { } });
            const blob = new Blob(chunks, { type: mimeType || "video/webm" });
            return { blob, mimeType: mimeType || blob.type || "video/webm", extension: "webm" };
        }

        // Build frame PNGs from the current modal sequence (raster or SVG)
        // Returns { ff, count, outName }
        async function buildFramesForCurrentSequence(ff, fps = 12) {
            const seq = MODAL.seq.slice(); if (!seq.length) throw new Error("empty sequence");
            // Use the first frame to lock dimensions
            const first = DATA[seq[0]];
            const firstImg = new Image(); firstImg.crossOrigin = "anonymous";
            const firstSrc = MODAL.svg ? await resolveSvgURL(svgTriesFor(first)) : rasterUrlFor(first);
            firstImg.src = EMBED_SVG_IN_MODAL && MODAL.svg ? (await fetchSvgAsDataURL(firstSrc)) : firstSrc;
            await new Promise((res, rej) => { firstImg.onload = res; firstImg.onerror = rej; });
            const W = firstImg.naturalWidth || 640, H = firstImg.naturalHeight || 480;

            const cv = document.createElement("canvas"); cv.width = W; cv.height = H;
            const ctx = cv.getContext("2d");

            let idx = 0;
            for (const gi of seq) {
                const it = DATA[gi];
                const img = new Image(); img.crossOrigin = "anonymous";
                if (MODAL.svg) {
                    const url = await resolveSvgURL(svgTriesFor(it));
                    img.src = EMBED_SVG_IN_MODAL ? (await fetchSvgAsDataURL(url)) : url;
                } else {
                    img.src = rasterUrlFor(it);
                }
                await new Promise((res, rej) => { img.onload = res; img.onerror = rej; });
                ctx.clearRect(0, 0, W, H);
                // Center-fit preserve aspect
                const r = Math.min(W / img.naturalWidth, H / img.naturalHeight);
                const dw = Math.round(img.naturalWidth * r), dh = Math.round(img.naturalHeight * r);
                const dx = Math.floor((W - dw) / 2), dy = Math.floor((H - dh) / 2);
                ctx.drawImage(img, dx, dy, dw, dh);
                const u8 = dataURLtoU8(cv.toDataURL("image/png"));
                const name = `f${String(++idx).padStart(5, "0")}.png`;
                ff.FS("writeFile", name, u8);
            }
            return { ff, count: idx, outName: "out.mp4" };
        }

        async function encodeMp4FromFrames(ff, fps = 12, out = "out.mp4") {
            // Prefer H.264 if available; fallback to mpeg4 if not compiled in this build
            try {
                await ff.run(
                    "-framerate", String(fps),
                    "-i", "f%05d.png",
                    "-c:v", "libx264",
                    "-pix_fmt", "yuv420p",
                    "-movflags", "+faststart",
                    out
                );
            } catch {
                await ff.run(
                    "-framerate", String(fps),
                    "-i", "f%05d.png",
                    "-c:v", "mpeg4",
                    "-qscale:v", "2",
                    "-vf", "format=yuv420p",
                    out
                );
            }
            const data = ff.FS("readFile", out);
            // Cleanup frames
            try {
                for (let i = 1; ; i++) {
                    const name = `f${String(i).padStart(5, "0")}.png`;
                    try { ff.FS("unlink", name); } catch { break; }
                }
                try { ff.FS("unlink", out); } catch { }
            } catch { }
            return new Blob([data.buffer], { type: "video/mp4" });
        }

        function downloadBlob(blob, baseName, extension) {
            const safeName = (baseName || "sequence").replace(/\s+/g, "_").replace(/[\/:*?"<>|]+/g, "-") || "sequence";
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${safeName}.${extension}`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => { try { URL.revokeObjectURL(url); } catch { } }, 4000);
        }

        // Click handler: try R2 full video first; if not available, encode the current sequence.
        async function onDownloadVideoClick() {
            try {
                const it = DATA[MODAL.seq[MODAL.pos]];
                // Attempt R2 "full source" video if we have a filename
                if (it && it.video_file) {
                    try {
                        toast("Opening original MP4…");
                        const opened = await downloadFullVideoFromR2(it.video_file);
                        if (opened) {
                            toast("Original MP4 opened in a new tab.");
                            return; // success path
                        }
                    } catch (e) {
                        console.warn("R2 presign failed, falling back to encode:", e);
                        toast("Original MP4 unavailable, building fallback…");
                    }
                }

                const baseName = it && it.video_file ? it.video_file.replace(/\.[^.]+$/, "") : "sequence";
                if (supportsCanvasRecording()) {
                    try {
                        toast("Building WebM from frames…");
                        const { blob, extension } = await encodeWebMFromSequence(MODAL.seq, 12);
                        downloadBlob(blob, baseName, extension);
                        toast("Video ready.");
                        return;
                    } catch (err) {
                        console.warn("Canvas recording fallback failed", err);
                    }
                }

                // Fallback: build MP4 from current sequence
                toast("Building MP4 from frames… (this may take 20–60s)");
                const ff = await loadFFmpeg();
                const { outName } = await buildFramesForCurrentSequence(ff, 12);
                const blob = await encodeMp4FromFrames(ff, 12, outName);
                downloadBlob(blob, baseName, "mp4");
                toast("MP4 ready.");
            } catch (e) {
                console.error(e);
                toast("MP4 download failed.");
            }
        }

        // Controls
        $("#sizeRange").addEventListener("input", () => { document.documentElement.style.setProperty("--thumb", $("#sizeRange").value + "px"); });
        $("#groupSelect").addEventListener("change", () => {
            $("#status").textContent = "Grouping...";
            setTimeout(() => { refresh(); /* status cleared in render */ }, 0);
        });
        $("#sortSelect").addEventListener("change", () => {
            const v = $("#sortSelect").value;
            if (isProSort(v) && !isPro()) {
                showProModal();
                // revert to previous allowed sort
                $("#sortSelect").value = sortMode;
                return;
            }
            refresh();
        });
        $("#sortDirBtn").addEventListener("click", () => { sortAsc = !sortAsc; $("#sortDirBtn").textContent = sortAsc ? "↑" : "↓"; refresh(); });
        $("#thumbMode").addEventListener("change", () => { refresh(); });
        $("#svgStyle").addEventListener("change", () => { });

        ["imgOnly", "hideDup", "hideTT", "motionTier"].forEach(id => $("#" + id).addEventListener("input", refresh));
        const debouncedRefresh = debounce(refresh, 150);
        $("#search").addEventListener("input", debouncedRefresh);

        $("#hmin").addEventListener("input", () => {
            const minVal = parseInt($("#hmin").value, 10), maxVal = parseInt($("#hmax").value, 10);
            if (minVal > maxVal) { $("#hmax").value = minVal; }
            updateHueRange(); refresh();
        });
        $("#hmax").addEventListener("input", () => {
            const minVal = parseInt($("#hmin").value, 10), maxVal = parseInt($("#hmax").value, 10);
            if (maxVal < minVal) { $("#hmin").value = maxVal; }
            updateHueRange(); refresh();
        });

        $("#resetBtn").addEventListener("click", () => {
            $("#sizeRange").value = 240; document.documentElement.style.setProperty("--thumb", "240px");
            $("#groupSelect").value = "none"; groupMode = "none";
            $("#sortSelect").value = "hue"; sortMode = "hue"; sortAsc = true; $("#sortDirBtn").textContent = "↑";
            $("#thumbMode").value = "object"; $("#svgStyle").value = "default";
            $("#imgOnly").checked = true; $("#hideDup").checked = false; $("#hideTT").checked = false;
            $("#hmin").value = 3; $("#hmax").value = 360; $("#hbadge").textContent = "3°–360°";
            $("#search").value = "";
            document.querySelectorAll('#shapeBox input[type=checkbox]').forEach(cb => cb.checked = true);
            document.querySelectorAll('#colorChips .chip').forEach(c => c.classList.remove("sel"));
            $("#motionTier").value = "any";
            refresh(); updateHueRange();
            currentView = "all"; updateNote(); const sEl = document.getElementById("status"); if (sEl) sEl.textContent = "";
        });

        function parseCsvText(text) {
            // You can keep your streaming integration; this parses once
            const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
            DATA = parsed.data.map(normalizeRow);
            // ... annotate, build filters, refresh, etc.
        }
        // Init
        
        (function init() {
            // Build UI immediately; stream CSV in chunks and paint incrementally.
            const PAGE = 500; // rows per paint
            let buffer = [];
            function flushPage(done=false){
                if (!buffer.length) return;
                const start = DATA.length;
                DATA.push(...buffer);
                buffer = [];
                // Lightweight annotation per row
                for (let i=start; i<DATA.length; i++){
                    const it = DATA[i];
                    const mv = num(it.motion, null);
                    it.motionTier = (mv === null) ? ((it.motion || "").toLowerCase().includes("fast") ? "high" : ((it.motion || "").toLowerCase().includes("drift") ? "med" : "low"))
                        : (mv <= 0.33 ? "low" : (mv <= 0.66 ? "med" : "high")); // rough default until full percentiles known
                    it.shape = it.shape || "other";
                    it.isDuplicate = false;
                    it.hasWatermark = it.video_file && it.video_file.toLowerCase().includes("tiktok");
                }
                // First paint builds filters/controls; later pages append
                if (start === 0){
                    buildShapeCheckboxes(); buildColorChips();
                    $("#groupSelect").value = "none"; $("#sortSelect").value = "hue";
                    $("#hmin").value = 3; $("#hbadge").textContent = `3°–${$("#hmax").value}°`;
                    refresh(); updateHueRange();
                } else {
                    // Integrate new rows according to current filters
                    const add = applyFilters();
                    // We don't want to rebuild everything; just reset stream and start streaming again
                    CURRENT = add; CURRENT_IDX = CURRENT.map(it => DATA.indexOf(it));
                    startStreaming();
                }
                if (done){
                    // recompute motion tiers more accurately using percentiles
                    const mvals = DATA.map(it => num(it.motion, null)).filter(v => v !== null);
                    if (mvals.length){
                        const sorted = mvals.slice().sort((a,b)=>a-b);
                        const pct = p => sorted[Math.max(0, Math.min(sorted.length-1, Math.floor(p*(sorted.length-1))))] ?? 0;
                        const t1 = pct(0.33), t2 = pct(0.66);
                        DATA.forEach(it => {
                            const mv = num(it.motion, null);
                            it.motionTier = (mv === null) ? it.motionTier : (mv <= t1 ? "low" : (mv <= t2 ? "med" : "high"));
                        });
                    }
                    try { dedupeByVideoClusters(); } catch {}
                    buildShapeCheckboxes();
                    buildColorChips();
                    refresh(); updateHueRange();
                    rebuildThumbIndex();
                    refreshCodebookSidebarPreviews();
                    if (resolveDataReady) { resolveDataReady(); resolveDataReady = null; }
                }
            }
            Papa.parse(CSV_URL, {
                download: true, header: true, skipEmptyLines: true, worker: true,
                chunk: ({ data }) => {
                    const rows = data.map(normalizeRow);
                    buffer.push(...rows);
                    if (buffer.length >= PAGE) flushPage(false);
                },
                complete: () => flushPage(true),
                error: (e) => { toast("Failed to load atlas.csv"); console.error(e); }
            });
        })();


        $("#closeModal").addEventListener("click", () => { $("#overlay").style.display = "none"; document.onkeydown = null; });
        $("#overlay").addEventListener("click", e => { if (e.target.id === "overlay") { $("#overlay").style.display = "none"; document.onkeydown = null; } });

        // Visitors (as in your current file)
        (function () {
            function getOrSetUID() {
                try {
                    let id = localStorage.getItem('uap_uid');
                    if (!id) {
                        id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).slice(2);
                        localStorage.setItem('uap_uid', id);
                        document.cookie = 'uap_uid=' + id + '; Path=/; Max-Age=' + (60 * 60 * 24 * 730);
                    }
                    return id;
                } catch (e) {
                    const m = document.cookie.match(/(?:^|;\s*)uap_uid=([^;]+)/); if (m) return m[1];
                    const id = Math.random().toString(36).slice(2);
                    document.cookie = 'uap_uid=' + id + '; Path=/; Max-Age=' + (60 * 60 * 24 * 730);
                    return id;
                }
            }
            async function postJSON(url, payload) {
                const res = await fetch(url, { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify(payload), credentials: 'same-origin' });
                if (!res.ok) throw new Error('HTTP ' + res.status); return res.json();
            }
            async function updateVisitorsBadge() {
                const el = document.getElementById('visitorsBadge'); if (!el) return;
                const uid = getOrSetUID();
                const endpoints = ['/api/unique', '/.netlify/functions/unique'];
                for (const url of endpoints) {
                    try {
                        const { total } = await postJSON(url, { visitorId: uid });
                        if (Number.isFinite(total)) { el.textContent = total + ' visitors'; return; }
                    } catch (e) { }
                }
                el.style.display = 'none';
            }
            updateVisitorsBadge();
        })();

        /* ===== Similar view implementation (bugfix) ===== */
        function findSimilarByGlobalIndex(gi) {
            const status = document.getElementById("status");
            const tgt = DATA[gi];
            // simple similarity metric (hue, s, v, circ, area + shape boost)
            const TH = hueOf(tgt), TS = num(tgt.s_norm, 0), TV = num(tgt.v_norm, 0), TC = num(tgt.circ, 0), TA = num(tgt.area_norm, 0);
            const tShape = tgt.shape;
            const requireImage = document.getElementById("imgOnly")?.checked ?? false;
            const hideDuplicates = document.getElementById("hideDup")?.checked ?? false;
            const sim = [];
            DATA.forEach((it, i) => {
                if (i === gi) return;
                if (requireImage && !hasThumbMedia(it)) return;
                if (hideDuplicates && it.isDuplicate) return;
                let d = 0; const H = hueOf(it);
                if (Number.isFinite(TH) && Number.isFinite(H)) { let dh = Math.abs(H - TH); dh = Math.min(dh, 360 - dh); d += (dh / 180); } else d += 1;
                d += Math.abs(num(it.s_norm, 0) - TS); d += Math.abs(num(it.v_norm, 0) - TV);
                d += Math.abs(num(it.circ, 0) - TC); d += Math.abs(num(it.area_norm, 0) - TA);
                if (tShape !== "other" && it.shape !== "other" && it.shape !== tShape) d += 2;
                sim.push({ i, d });
            });
            sim.sort((a, b) => a.d - b.d);
            const top = [];
            for (const s of sim) {
                top.push(s.i);
                if (top.length >= 30) break;
            }
            CURRENT = [tgt, ...top.map(i => DATA[i])];
            CURRENT_IDX = [gi, ...top];
            currentView = "similar";
            startStreaming(); // sets note + clears status
            if (status) status.textContent = "";
        }
    </script>
</body>
</html>
